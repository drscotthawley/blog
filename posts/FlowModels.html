<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Scott H. Hawley">
<meta name="dcterms.date" content="2024-11-13">
<meta name="description" content="Basic physics provides a “straight, fast” way to get up to speed with flow-based generative models">

<title>blog - Flow With What You Know</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
details > summary {
    color: #00966f;   /* the greenish tinge that appears in my blog */
    cursor: pointer; /* lil triangle thingy */
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="blog - Flow With What You Know">
<meta property="og:description" content="Basic physics provides a “straight, fast” way to get up to speed with flow-based generative models">
<meta property="og:image" content="https://drscotthawley.github.io/blog/posts/images/flow_gaussian_to_spiral.png">
<meta property="og:site-name" content="blog">
<meta property="og:image:height" content="298">
<meta property="og:image:width" content="640">
<meta name="twitter:title" content="blog - Flow With What You Know">
<meta name="twitter:description" content="Basic physics provides a “straight, fast” way to get up to speed with flow-based generative models">
<meta name="twitter:image" content="https://drscotthawley.github.io/blog/posts/images/flow_gaussian_to_spiral.png">
<meta name="twitter:image-height" content="298">
<meta name="twitter:image-width" content="640">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/drscotthawley" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/drscotthawley" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Flow With What You Know</h1>
                  <div>
        <div class="description">
          Basic physics provides a “straight, fast” way to get up to speed with flow-based generative models
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">generative</div>
                <div class="quarto-category">flows</div>
                <div class="quarto-category">diffusion</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Scott H. Hawley </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 13, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a>
  <ul class="collapse">
  <li><a href="#whats-a-flow" id="toc-whats-a-flow" class="nav-link" data-scroll-target="#whats-a-flow"><span class="header-section-number">1.1</span> What’s a Flow?</a></li>
  </ul></li>
  <li><a href="#how-do-fmrf-models-work" id="toc-how-do-fmrf-models-work" class="nav-link" data-scroll-target="#how-do-fmrf-models-work"><span class="header-section-number">2</span> How Do FM/RF Models Work?</a>
  <ul class="collapse">
  <li><a href="#the-starting-setup" id="toc-the-starting-setup" class="nav-link" data-scroll-target="#the-starting-setup"><span class="header-section-number">2.1</span> The Starting Setup</a></li>
  <li><a href="#how-are-flows-learned" id="toc-how-are-flows-learned" class="nav-link" data-scroll-target="#how-are-flows-learned"><span class="header-section-number">2.2</span> How Are Flows “Learned”?</a>
  <ul class="collapse">
  <li><a href="#the-neural-networks-job" id="toc-the-neural-networks-job" class="nav-link" data-scroll-target="#the-neural-networks-job"><span class="header-section-number">2.2.1</span> The Neural Network’s Job</a></li>
  </ul></li>
  <li><a href="#training-code" id="toc-training-code" class="nav-link" data-scroll-target="#training-code"><span class="header-section-number">2.3</span> Training Code</a></li>
  </ul></li>
  <li><a href="#reflow-to-go-straighter-faster" id="toc-reflow-to-go-straighter-faster" class="nav-link" data-scroll-target="#reflow-to-go-straighter-faster"><span class="header-section-number">3</span> “Reflow” to Go Straighter &amp; Faster</a>
  <ul class="collapse">
  <li><a href="#upgrading-our-gear-first" id="toc-upgrading-our-gear-first" class="nav-link" data-scroll-target="#upgrading-our-gear-first"><span class="header-section-number">3.1</span> Upgrading Our Gear First</a>
  <ul class="collapse">
  <li><a href="#more-points-where-needed-via-time-warping" id="toc-more-points-where-needed-via-time-warping" class="nav-link" data-scroll-target="#more-points-where-needed-via-time-warping"><span class="header-section-number">3.1.1</span> More Points Where Needed (via Time Warping)</a></li>
  <li><a href="#better-integration-sampling" id="toc-better-integration-sampling" class="nav-link" data-scroll-target="#better-integration-sampling"><span class="header-section-number">3.1.2</span> Better Integration / Sampling</a></li>
  </ul></li>
  <li><a href="#learning-to-reflow" id="toc-learning-to-reflow" class="nav-link" data-scroll-target="#learning-to-reflow"><span class="header-section-number">3.2</span> Learning to “ReFlow”</a>
  <ul class="collapse">
  <li><a href="#train-the-reflowed-model" id="toc-train-the-reflowed-model" class="nav-link" data-scroll-target="#train-the-reflowed-model"><span class="header-section-number">3.2.1</span> Train the Reflowed Model</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#connecting-with-other-models" id="toc-connecting-with-other-models" class="nav-link" data-scroll-target="#connecting-with-other-models"><span class="header-section-number">4</span> Connecting with Other Models</a>
  <ul class="collapse">
  <li><a href="#from-dots-to-images-audio-etc.." id="toc-from-dots-to-images-audio-etc.." class="nav-link" data-scroll-target="#from-dots-to-images-audio-etc.."><span class="header-section-number">4.1</span> From Dots to Images, Audio, etc..</a></li>
  <li><a href="#diffusion-models" id="toc-diffusion-models" class="nav-link" data-scroll-target="#diffusion-models"><span class="header-section-number">4.2</span> Diffusion Models</a></li>
  <li><a href="#optimal-transport" id="toc-optimal-transport" class="nav-link" data-scroll-target="#optimal-transport"><span class="header-section-number">4.3</span> Optimal Transport</a></li>
  <li><a href="#normalizing-flows" id="toc-normalizing-flows" class="nav-link" data-scroll-target="#normalizing-flows"><span class="header-section-number">4.4</span> Normalizing Flows</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">5</span> Summary</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">6</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<style>
figcaption {
  margin: auto;
  text-align: center;
</style>
<div style="text-align: right;">
<p><a href="https://colab.research.google.com/github/drscotthawley/blog/blob/main/extra/FlowModels_colab.ipynb"> <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"> </a></p>
</div>
<section id="abstract" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="abstract">Abstract</h3>
<p>In this tutorial post, we provide an accessible introduction to flow-matching and rectified flow models, which are increasingly at the forefront of generative AI applications. Typical descriptions of them are usually laden with extensive probability-math equations, which can form barriers to the dissemination and understanding of these models. Fortunately, before they were couched in probabilities, the mechanisms underlying these models were grounded in basic physics, which provides an alternative and highly accessible (yet functionally equivalent) representation of the processes involved. Let’s flow.</p>
</section>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Flow-based generative AI models have been gaining significant traction as alternatives or improvements to traditional diffusion approaches in image and audio synthesis. These models excel at learning optimal trajectories for transforming probability distributions, offering a mathematically elegant framework for data generation. The approach has seen renewed momentum following Black Forest Labs’ success with their FLUX models <span class="citation" data-cites="flux_paper"><a href="#ref-flux_paper" role="doc-biblioref">[1]</a></span>, spurring fresh interest in the theoretical foundations laid by earlier work on Rectified Flows <span class="citation" data-cites="rectified_flow"><a href="#ref-rectified_flow" role="doc-biblioref">[2]</a></span> in ICLR 2023. Improvements such as <span class="citation" data-cites="improving_rf"><a href="#ref-improving_rf" role="doc-biblioref">[3]</a></span> have even reached the level of state-of-the-art generative models for one or two-step generation.</p>
<p>Intuitively, these models operate akin to the fluid processes that transform the shapes of clouds in the sky. While recent expositions <span class="citation" data-cites="jia_bin"><a href="#ref-jia_bin" role="doc-biblioref">[4]</a></span> have attempted to make these concepts more accessible through probability theory, the underlying physical principles offer a more direct path to understanding. By returning to the basic physical picture of flows that inspired these generative models, we can build both intuition and deep understanding - insights that may even guide the development of new approaches.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mj-bw.gif" height="300" class="figure-img"></p>
<figcaption class="figure-caption">Source: Face-morphing example from Michael Jackson’s “Black Or White” (1991). <br>While technically not a flow-based generative model <span class="citation" data-cites="mj_siggraph"><a href="#ref-mj_siggraph" role="doc-biblioref">[5]</a></span>, it’s similar enough to use for an intro image. ;-)</figcaption>
</figure>
</div>
<section id="whats-a-flow" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="whats-a-flow"><span class="header-section-number">1.1</span> What’s a Flow?</h2>
<p>In the real world, things typically follow curved paths - like water flowing in a river, or crowds of people navigating around obstacles. Here’s a map of wind provided by the WW2010 atmospheric science project at UIUC: at every point in space, the wind has a velocity vector, and the air moves along “streamlines” or “trajectories” parallel to the velocity vectors…</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/3wndhght.gif" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Wind flow map image from the <a href="http://ww2010.atmos.uiuc.edu/(Gh)/guides/maps/upa/wndvct.rxml">University of Illinois WW2010 Project</a></figcaption>
</figure>
</div>
<p>Notice that the streamlines never cross. If the streams were to cross… “it would be bad.” That would imply that the velocity at some point is undefined.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/gb-dont-cross-streams.gif" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Non-Crossing == Invertible">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Non-Crossing == Invertible
</div>
</div>
<div class="callout-body-container callout-body">
<p>This non-crossing property is what allows these flows to be invertible (i.e., reversible), a property you sometimes hear in isolation when reading more formal descriptions of flow models.</p>
</div>
</div>
<p>So, at every point in space there’s a velocity vector telling the little bits of fluid where to go. And just like water or wind flows may depend not only on spatial position but also time, so too can our velocity vector field depend on position and time.</p>
<p>Flow matching learns these natural paths by focusing on the <em>velocity</em> at each point - essentially asking, “Which way should each data point be moving at this moment?”</p>
<div class="callout callout-style-default callout-note callout-titled" title="Terminology: &quot;FM/RF&quot;">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Terminology: “FM/RF”
</div>
</div>
<div class="callout-body-container callout-body">
<p>It may seem confusing to sometimes see “flow matching” and “rectified flows” being used interchangeably, but this is because they are <em>the same</em> <span class="citation" data-cites="tanishq_same"><a href="#ref-tanishq_same" role="doc-biblioref">[6]</a></span>. In this blog post, we’ll use the collective term “FM/RF” models.<br>
Also note that there is no explicit “rectification” mechanism in rectified flows; rather any “rectification” is a description of the effect of flow-matching, i.e.&nbsp;transforming crossing trajectories to non-crossing ones. The addition of “Reflow” to the rectified flow paper <span class="citation" data-cites="rectified_flow"><a href="#ref-rectified_flow" role="doc-biblioref">[2]</a></span> is a powerful extension we will cover further below.</p>
</div>
</div>
</section>
</section>
<section id="how-do-fmrf-models-work" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> How Do FM/RF Models Work?</h1>
<p>To gain a deep understanding of how models work, having an executable toy model is often a key instructional tool. This tutorial is written as an <a href="https://colab.research.google.com/github/drscotthawley/blog/blob/main/extra/FlowModels_colab.ipynb">executable Jupyter notebook</a>, though you can make sense of it without the code, so we will typically collapse or hide the code. But if you want to see it, you can expand the drop-down arrows.</p>
<p>For instance, the code starts with importing packages…</p>
<div class="cell">
<details>
<summary>Installs &amp; imports</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment to install any missing packages:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#%pip install torch numpy matplotlib tqdm </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline  </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> HTML, display, clear_output</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm.notebook <span class="im">import</span> tqdm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><strong>Choose Your Own Data Shapes</strong></p>
<p>The <a href="https://colab.research.google.com/github/drscotthawley/blog/blob/main/extra/FlowModels_colab.ipynb">executable version of this lesson</a> lets you choose various shapes to “morph” between. For this reading, we’ll go from a Gaussian to a Spiral:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Options are: 'Gaussian', 'Square', 'Heart', 'Spiral', 'Two Gaussians', 'Smiley'</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>source_data_choice <span class="op">=</span> <span class="st">'Gaussian'</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>target_data_choice <span class="op">=</span> <span class="st">'Spiral'</span>       </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Flow models don’t require gaussian prior distributions. You can choose whatever you want.</p>
</div>
</div>
<p>With the imports in place and the choice of starting and ending distributions chosen, we’re ready to define some utilities to generate and visualize our data. Let’s take a look:</p>
<div class="cell">
<details>
<summary>Utility code: styles, functions, generators, visualization</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for accessibility: Wong's color pallette: cf. https://davidmathlogic.com/colorblind</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#wong_black = [0/255, 0/255, 0/255]          # #000000</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>wong_amber <span class="op">=</span> [<span class="dv">230</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">159</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">0</span><span class="op">/</span><span class="dv">255</span>]      <span class="co"># #E69F00</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>wong_cyan <span class="op">=</span> [<span class="dv">86</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">180</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">233</span><span class="op">/</span><span class="dv">255</span>]      <span class="co"># #56B4E9</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>wong_green <span class="op">=</span> [<span class="dv">0</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">158</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">115</span><span class="op">/</span><span class="dv">255</span>]      <span class="co"># #009E73</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>wong_yellow <span class="op">=</span> [<span class="dv">240</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">228</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">66</span><span class="op">/</span><span class="dv">255</span>]    <span class="co"># #F0E442</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>wong_navy <span class="op">=</span> [<span class="dv">0</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">114</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">178</span><span class="op">/</span><span class="dv">255</span>]       <span class="co"># #0072B2</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>wong_red <span class="op">=</span> [<span class="dv">213</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">94</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">0</span><span class="op">/</span><span class="dv">255</span>]         <span class="co"># #D55E00</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>wong_pink <span class="op">=</span> [<span class="dv">204</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">121</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">167</span><span class="op">/</span><span class="dv">255</span>]     <span class="co"># #CC79A7</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>wong_cmap <span class="op">=</span> [wong_amber, wong_cyan, wong_green, wong_yellow, wong_navy, wong_red, wong_pink]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>source_color <span class="op">=</span> wong_navy</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>target_color <span class="op">=</span> wong_red</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>pred_color <span class="op">=</span> wong_green</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>line_color <span class="op">=</span> wong_yellow</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>bg_theme <span class="op">=</span> <span class="st">'dark'</span> <span class="co">#  'black', 'white', 'dark', 'light'</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> bg_theme <span class="kw">in</span> [<span class="st">'black'</span>,<span class="st">'dark'</span>]:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    plt.style.use(<span class="st">'dark_background'</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    plt.rcdefaults()</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co"># A few different data distributions</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_gaussian_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a 2D Gaussian distribution"""</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.randn(n_points, <span class="dv">2</span>) <span class="op">*</span> scale</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_square_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">3.0</span>):  <span class="co"># 3 is set by the spread of the gaussian and spiral </span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create points uniformly distributed in a square"""</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate uniform points in a square</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> (torch.rand(n_points, <span class="dv">2</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> scale</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> points</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_spiral_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a spiral distribution. i like this one more"""</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    noise <span class="op">=</span> <span class="fl">0.1</span><span class="op">*</span>scale </span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">#theta = torch.linspace(0, 6*np.pi, n_points) # preferred order? no way</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> <span class="dv">6</span><span class="op">*</span>np.pi<span class="op">*</span> torch.rand(n_points)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> theta <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>np.pi) <span class="op">*</span> scale</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> r <span class="op">*</span> torch.cos(theta) <span class="op">+</span> noise <span class="op">*</span> torch.randn(n_points)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> r <span class="op">*</span> torch.sin(theta) <span class="op">+</span> noise <span class="op">*</span> torch.randn(n_points)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack([x, y], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_heart_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">3.0</span>):</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a heart-shaped distribution of points"""</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    square_points <span class="op">=</span> create_square_data(n_points, scale<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the heart-shaped condition for each point</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> square_points[:, <span class="dv">0</span>], square_points[:, <span class="dv">1</span>]</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    heart_condition <span class="op">=</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((<span class="dv">5</span> <span class="op">*</span> (y <span class="op">+</span> <span class="fl">0.25</span>) <span class="op">/</span> <span class="dv">4</span>) <span class="op">-</span> torch.sqrt(torch.<span class="bu">abs</span>(x)))<span class="op">**</span><span class="dv">2</span> <span class="op">&lt;=</span> <span class="dv">1</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter out points that don't satisfy the heart-shaped condition</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    heart_points <span class="op">=</span> square_points[heart_condition]</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we don't have enough points, generate more</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(heart_points) <span class="op">&lt;</span> n_points:</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>        new_points <span class="op">=</span> create_square_data(n_points <span class="op">-</span> <span class="bu">len</span>(heart_points), scale<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> new_points[:, <span class="dv">0</span>], new_points[:, <span class="dv">1</span>]</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>        new_heart_condition <span class="op">=</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((<span class="dv">5</span> <span class="op">*</span> (y <span class="op">+</span> <span class="fl">0.25</span>) <span class="op">/</span> <span class="dv">4</span>) <span class="op">-</span> torch.sqrt(torch.<span class="bu">abs</span>(x)))<span class="op">**</span><span class="dv">2</span> <span class="op">&lt;=</span> <span class="dv">1</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>        new_heart_points <span class="op">=</span> new_points[new_heart_condition]</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>        heart_points <span class="op">=</span> torch.cat([heart_points, new_heart_points], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>    heart_points <span class="op">*=</span> scale </span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> heart_points[:n_points]</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_two_gaussians_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">1.0</span>, shift<span class="op">=</span><span class="fl">2.5</span>):</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a 2D Gaussian distribution"""</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>    g  <span class="op">=</span> torch.randn(n_points, <span class="dv">2</span>) <span class="op">*</span> scale</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>    g[:n_points<span class="op">//</span><span class="dv">2</span>,<span class="dv">0</span>] <span class="op">-=</span> shift</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>    g[n_points<span class="op">//</span><span class="dv">2</span>:,<span class="dv">0</span>] <span class="op">+=</span> shift</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> torch.randperm(n_points)</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g[indices]</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_smiley_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">2.5</span>):</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>    <span class="co">"make a smiley face"</span></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> []</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Face circle</span></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">#angles = 2 * np.pi * torch.rand(n_points//2+20)</span></span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>    <span class="co">#r = scale + (scale/10)*torch.sqrt(torch.rand(n_points//2+20)) </span></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">#points.append(torch.stack([r * torch.cos(angles), r * torch.sin(angles)], dim=1))</span></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Eyes (small circles at fixed positions)</span></span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> eye_pos <span class="kw">in</span> [[<span class="op">-</span><span class="dv">1</span>, <span class="fl">0.9</span>], [<span class="dv">1</span>, <span class="fl">0.9</span>]]:</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>        eye <span class="op">=</span> torch.randn(n_points<span class="op">//</span><span class="dv">3</span><span class="op">+</span><span class="dv">20</span>, <span class="dv">2</span>) <span class="op">*</span> <span class="fl">0.2</span> <span class="op">+</span> torch.tensor(eye_pos) <span class="op">*</span> scale <span class="op">*</span> <span class="fl">0.4</span></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>        points.append(eye)</span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Smile (arc in polar coordinates)</span></span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> <span class="op">-</span>np.pi<span class="op">/</span><span class="dv">6</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.pi<span class="op">/</span><span class="dv">3</span><span class="op">*</span>torch.rand(n_points<span class="op">//</span><span class="dv">3</span><span class="op">+</span><span class="dv">20</span>) </span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>    r_smile <span class="op">=</span> scale <span class="op">*</span> <span class="fl">0.6</span> <span class="op">+</span> (scale<span class="op">/</span><span class="dv">4</span>)<span class="op">*</span> torch.rand_like(theta)</span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>    points.append(torch.stack([r_smile <span class="op">*</span> torch.cos(theta), r_smile <span class="op">*</span> torch.sin(theta)], dim<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> torch.cat(points, dim<span class="op">=</span><span class="dv">0</span>)  <span class="co"># concatenate first</span></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> points[torch.randperm(points.shape[<span class="dv">0</span>])]  <span class="co"># then shuffle</span></span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> points[:n_points,:]</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize generator functions</span></span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>source_gen_fn <span class="op">=</span> <span class="va">None</span></span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>target_gen_fn <span class="op">=</span> <span class="va">None</span></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign generator functions based on user choices</span></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> gen_choice, gen_fn_name <span class="kw">in</span> <span class="bu">zip</span>([source_data_choice, target_data_choice], [<span class="st">'source_gen_fn'</span>, <span class="st">'target_gen_fn'</span>]):</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>    gen_choice <span class="op">=</span> gen_choice.lower()</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'two gaussians'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_two_gaussians_data</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'heart'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_heart_data</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'spiral'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_spiral_data</span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'square'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_square_data</span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'smiley'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_smiley_data</span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_gaussian_data</span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> gen_fn_name <span class="op">==</span> <span class="st">'source_gen_fn'</span>:</span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>        source_gen_fn <span class="op">=</span> gen_fn</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>        target_gen_fn <span class="op">=</span> gen_fn</span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a><span class="co"># A couple aliases so we can easily switch distributions without affecting later code </span></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_source_data(n_points<span class="op">=</span><span class="dv">1000</span>, hshift<span class="op">=</span><span class="dv">0</span>):  <span class="co"># hshift can make it a bit easier to see trajectories later</span></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> source_gen_fn(n_points<span class="op">=</span>n_points)</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> hshift <span class="op">!=</span> <span class="dv">0</span>: g[:,<span class="dv">0</span>] <span class="op">+=</span> hshift</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_target_data(n_points<span class="op">=</span><span class="dv">1000</span>, hshift<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> target_gen_fn(n_points<span class="op">=</span>n_points)</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> hshift <span class="op">!=</span> <span class="dv">0</span>: g[:,<span class="dv">0</span>] <span class="op">+=</span> hshift</span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_distributions(dist1, dist2, title1<span class="op">=</span><span class="st">"Distribution 1"</span>, title2<span class="op">=</span><span class="st">"Distribution 2"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>):</span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Plot two distributions side by side"""</span></span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>    plt.close(<span class="st">'all'</span>)</span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>    ax1.scatter(dist1[:, <span class="dv">0</span>], dist1[:, <span class="dv">1</span>], alpha<span class="op">=</span>alpha, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>source_color)</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a>    ax2.scatter(dist2[:, <span class="dv">0</span>], dist2[:, <span class="dv">1</span>], alpha<span class="op">=</span>alpha, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>target_color)</span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(title1)</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(title2)</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set same scale for both plots</span></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(dist1).<span class="bu">max</span>().item(),</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(dist2).<span class="bu">max</span>().item()</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ax <span class="kw">in</span> [ax1, ax2]:</span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>        ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>    plt.show()  <span class="co"># Explicitly show the plot</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpolate_color(t, start<span class="op">=</span><span class="st">'blue'</span>, end<span class="op">=</span><span class="st">'red'</span>):</span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Interpolate from matplotlib's default green (t=0) to red (t=1)"""</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>    start_color <span class="op">=</span> plt.cm.colors.to_rgb(start)</span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>    end_color <span class="op">=</span> plt.cm.colors.to_rgb(end)</span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">1</span><span class="op">-</span>t) <span class="op">*</span> np.array(start_color) <span class="op">+</span> t <span class="op">*</span> np.array(end_color)</span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> show_flow_sequence(start_dist, end_dist, n_steps<span class="op">=</span><span class="dv">5</span>, c_start<span class="op">=</span>source_color, c_end<span class="op">=</span>target_color):</span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Show the flow as a sequence of static plots"""</span></span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_steps, figsize<span class="op">=</span>(<span class="dv">4</span><span class="op">*</span>n_steps, <span class="dv">4</span>))</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(start_dist).<span class="bu">max</span>().item(),</span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(end_dist).<span class="bu">max</span>().item()</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axes):</span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> i <span class="op">/</span> (n_steps <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> start_dist <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>t) <span class="op">+</span> end_dist <span class="op">*</span> t</span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> interpolate_color(t, start<span class="op">=</span>c_start, end<span class="op">=</span>c_end)</span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>        ax.scatter(current[:, <span class="dv">0</span>], current[:, <span class="dv">1</span>], </span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>                  alpha<span class="op">=</span><span class="fl">0.8</span>, s<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>                  c<span class="op">=</span>[color])</span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>        ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f't = </span><span class="sc">{</span>t<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a><span class="co"># Create our distributions and look at them</span></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>n_points <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>source, target <span class="op">=</span> create_source_data(n_points), create_target_data(n_points)</span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a>plot_distributions(source, target, <span class="st">"Starting Distribution"</span>, <span class="st">"Target Distribution"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The process of transition from the starting “source” to the final “target” might include snapshots like these:</p>
<div class="cell">
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-5-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>(Note the colors aren’t meaningful, they’re just added to make it easier to distinguish what we’re looking at. Our data are just points in 2-D space.)</p>
<!---Here's an animation with no colors, showing the points moving. ... --->
<p>So, how do we get the points from the source distribution to fit with the target distribution? The simplest way (though not the only way) is to assume points move in straight lines from source to target. Even though our network might learn more complex paths later, this gives us a starting point for training.</p>
<section id="the-starting-setup" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="the-starting-setup"><span class="header-section-number">2.1</span> The Starting Setup</h2>
<p>The training setup for flow matching models is as follows:</p>
<ol type="1">
<li>We start by <em>randomly pairing</em> points from the source &amp; the target – yes, really. 🤣</li>
<li>We move the points along straight trajectories, and the speed of each point is constant.</li>
</ol>
<div class="cell">
<details>
<summary>Code for 2D flow-matching diagram with crossing lines</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>source_L <span class="op">=</span> source.clone()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>shift <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>source_L[:,<span class="dv">0</span>] <span class="op">-=</span> shift</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>target_R <span class="op">=</span> target.clone()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>target_R[:,<span class="dv">0</span>] <span class="op">+=</span> shift  <span class="co"># Note: fixed the indexing here from [:0] to [:,0]</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># show the whole distribution</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>ax.scatter(source_L[:,<span class="dv">0</span>], source_L[:,<span class="dv">1</span>], color<span class="op">=</span>source_color, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>ax.scatter(target_R[:,<span class="dv">0</span>], target_R[:,<span class="dv">1</span>], color<span class="op">=</span>target_color, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw lines connecting points, with source &amp; target points outlined</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>n_lines <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>ax.scatter(source_L[:n_lines,<span class="dv">0</span>], source_L[:n_lines,<span class="dv">1</span>], color<span class="op">=</span>source_color, alpha<span class="op">=</span><span class="fl">0.5</span>, </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>           facecolor<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span>line_color,)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>ax.scatter(target_R[:n_lines,<span class="dv">0</span>], target_R[:n_lines,<span class="dv">1</span>], color<span class="op">=</span>target_color, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>           facecolor<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span>line_color,)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_lines):</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    ax.plot([source_L[i,<span class="dv">0</span>], target_R[i,<span class="dv">0</span>]], </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        [source_L[i,<span class="dv">1</span>], target_R[i,<span class="dv">1</span>]], </span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span>line_color<span class="op">+</span>[<span class="fl">.9</span>], </span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        linewidth<span class="op">=</span><span class="dv">2</span>)  <span class="co"># or lw=2</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'top'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'right'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'bottom'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'left'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> [x, label] <span class="kw">in</span> <span class="bu">zip</span>([<span class="op">-</span>shift,shift], [<span class="st">'Source'</span>,<span class="st">'Target'</span>]):</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    ax.text(x, <span class="dv">4</span>, label, fontsize<span class="op">=</span><span class="dv">12</span>, color<span class="op">=</span><span class="st">'black'</span>, ha<span class="op">=</span><span class="st">'center'</span>,  va<span class="op">=</span><span class="st">'center'</span>,)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="co">#plt.show()</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>os.makedirs(<span class="st">'images'</span>, exist_ok<span class="op">=</span><span class="va">True</span>) </span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>save_file<span class="op">=</span><span class="st">'images/gaussian_to_spiral_crossing_lines.png'</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>plt.savefig(save_file)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="co">#plt.show()</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="co">#HTML(f"""&lt;center&gt;&lt;img src="{save_file}" width="600"&gt;&lt;/center&gt;""") </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/gaussian_to_spiral_crossing_lines.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Straight Trajectories == Linear Interpolation
</div>
</div>
<div class="callout-body-container callout-body">
<p>The idea of guessing straight trajectories at constant speed is <em>identical</em> to simple linear interpolation between source and target data points.</p>
</div>
</div>
<p>There are big issues with doing this: The random pairing results in lots of trajectories that cross each other. But this is a <em>starting point</em> for Flow Matching. So in other words, when training a Flow Matching model…</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/gb-well-cross-streams.gif" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>…well, ok not quite: we’re going to allow the <em>trajectories of individual points</em> to cross as we train the model. This <em>is</em> a bit “confusing” for the model, which will be trying to learn a velocity field, and that isn’t defined where trajectories cross. Eventually, however, the model will learn to estimate the <em>aggregated motion</em> of many particles, which will sort of average out to arrive at the “bulk motion” of the flow. This is similar to how the Brownian motion <span class="citation" data-cites="brownian_motion"><a href="#ref-brownian_motion" role="doc-biblioref">[7]</a></span> of many air or water particles averages out on the macroscopic level, giving us streamlines that don’t cross.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>This is why flow matching is about transforming <em>distributions</em>, not individual points. The learned velocity field might not exactly match any of our training trajectories, but it captures the statistical flow needed to transform one distribution into another.</p>
<p>Here’s a visualization from the code we’ll execute later in the lesson. We’ll plot…</p>
<ol type="1">
<li>Our naive training trajectories (with crossings)</li>
<li>The actual learned flow field (i.e., the velocity vector field)</li>
<li>The paths (aka “trajectories”) that data points follow when flowing with the learned field</li>
</ol>
<p><img src="images/cross_uncross_plot.png" class="img-fluid"> Left: Training data uses simple straight lines (with many crossings). Middle: The learned flow (velocity vector) field is smooth and continuous. Right: Actual trajectories following the flow field don’t cross.</p>
</section>
<section id="how-are-flows-learned" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="how-are-flows-learned"><span class="header-section-number">2.2</span> How Are Flows “Learned”?</h2>
<p>The goal of the machine learning system is as follows: for any point in space and any time t between 0 and 1, we want to learn the correct <em>velocity</em> (direction and speed) that point should move. It’s like learning the “wind map” that will blow the starting distribution cloud into the shape of the target distribution cloud.</p>
<p>Since neural networks are such useful engines for approximation and interpolation, we’ll let a neural network “learn” to estimate the mapping between locations and times (as inputs), and velocities (as outputs).</p>
<div class="callout callout-style-default callout-note callout-titled" title="Terminology: &quot;Simulation Free&quot;">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Terminology: “Simulation Free”
</div>
</div>
<div class="callout-body-container callout-body">
<p>You’ll sometimes see flow-maching models being referred to as “simulation free.” This is just an indication that the flow we arrive at is not the result of any explicit simulation of any process (physical or otherwise). The flow obtained arises simply from the aggregation (or “averaging out”) of many particles moving along imagined straight lines and crossing paths.</p>
</div>
</div>
<section id="the-neural-networks-job" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="the-neural-networks-job"><span class="header-section-number">2.2.1</span> The Neural Network’s Job</h3>
<p>The neural network has one job: given a position in space and a time, to output a velocity vector. <em>That’s all it does.</em> Below is the code for this model that will “learn” to estimate velocity vectors.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VelocityNet(nn.Module):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_dim, h_dim<span class="op">=</span><span class="dv">64</span>):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc_in  <span class="op">=</span> nn.Linear(input_dim <span class="op">+</span> <span class="dv">1</span>, h_dim)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc2    <span class="op">=</span> nn.Linear(h_dim, h_dim)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc3    <span class="op">=</span> nn.Linear(h_dim, h_dim)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc_out <span class="op">=</span> nn.Linear(h_dim, input_dim)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x, t, act<span class="op">=</span>F.gelu):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> t.expand(x.size(<span class="dv">0</span>), <span class="dv">1</span>)  <span class="co"># Ensure t has the correct dimensions</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.cat([x, t], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> act(<span class="va">self</span>.fc_in(x))</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> act(<span class="va">self</span>.fc2(x))</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> act(<span class="va">self</span>.fc3(x))</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.fc_out(x)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Instantiate the model</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>input_dim <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> VelocityNet(input_dim)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>…That’s it! Looks pretty simple, right? That’s because to make the system work we’ll need more than just the velocity field model.</p>
<p>Apart from the velocity model (i.e., the neural network, for us), the rest of the software system then uses these generated velocities to move points around. The model’s velocities are then used in a differential equation describing the small change to each particle’s position <span class="math inline">\(\vec{r}\)</span> over a short time <span class="math inline">\(dt\)</span>:</p>
<p><span class="math display">\[ d\vec{r} = v(\vec{r},t) dt\]</span></p>
<p>That equation is integrated by some (totally separate) numerical integration routine. A popular choice in the machine learning world is the “forward Euler” method, which is simple to implement, but will need to be upgraded (see further below) to get good results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fwd_euler_step(model, current_points, current_t, dt):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    velocity <span class="op">=</span> model(current_points, current_t)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_points <span class="op">+</span> velocity <span class="op">*</span> dt </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<details>
<summary>Integrator code: generate/predict samples using the trained model</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integrate_path(model, initial_points, step_fn<span class="op">=</span>fwd_euler_step, n_steps<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                   save_trajectories<span class="op">=</span><span class="va">False</span>, warp_fn<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""this 'sampling' routine is primarily used for visualization."""</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    current_points <span class="op">=</span> initial_points.clone()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    ts <span class="op">=</span>  torch.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n_steps).to(device)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> warp_fn: ts <span class="op">=</span> warp_fn(ts)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_trajectories: trajectories <span class="op">=</span> [current_points]    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ts)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        current_points <span class="op">=</span> step_fn(model, current_points, ts[i], ts[i<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>ts[i])</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> save_trajectories: trajectories.append(current_points)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_trajectories: <span class="cf">return</span> current_points, torch.stack(trajectories).cpu()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_points </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>generate_samples <span class="op">=</span> integrate_path <span class="co"># just lil' alias for the probability / diffusion model crowd ;-) </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="training-code" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="training-code"><span class="header-section-number">2.3</span> Training Code</h2>
<p>The goal of the training code is twofold: 1. to expose the model to as many locations and times as possible – at least for those times &amp; locations that “matter most”. This exposure is what I’ll refer to as “coverage”. 2. to force it to learn to generate (approximately) correct velocities at those times and locations.</p>
<p>That’s it. The training code doesn’t actually do any integration or solving, but we’ll typically execute the integration just to visualize “how we’re doing” as the training progresses.</p>
<div class="cell">
<details>
<summary>Viz code: calls integrator to calc motion given v field, makes pictures</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> viz(val_points, target_samples, trained_model, size<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, n_steps<span class="op">=</span><span class="dv">100</span>, warp_fn<span class="op">=</span><span class="va">None</span>,):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate and visualize new samples</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(trained_model.parameters()).device</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    generated_samples, trajectories <span class="op">=</span> integrate_path(trained_model, val_points.to(device), n_steps<span class="op">=</span>n_steps, warp_fn<span class="op">=</span>warp_fn, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    n_viz <span class="op">=</span> <span class="bu">min</span>(<span class="dv">30</span>, <span class="bu">len</span>(trajectories[<span class="dv">0</span>]))  <span class="co"># Number of trajectories to visualize</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">13</span>,<span class="dv">3</span>))</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    data_list <span class="op">=</span> [val_points.cpu(), generated_samples.cpu(), target_samples.cpu()] </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    label_list <span class="op">=</span> [<span class="st">'Initial Points'</span>, <span class="st">'Generated Samples'</span>, <span class="st">'Target Data'</span>,<span class="st">'Trajectories'</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    color_list <span class="op">=</span> [source_color, pred_color, target_color]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    global_max <span class="op">=</span> <span class="bu">max</span>( torch.<span class="bu">max</span>(torch.<span class="bu">abs</span>(torch.cat(data_list)),<span class="dv">0</span>)[<span class="dv">0</span>][<span class="dv">0</span>],  torch.<span class="bu">max</span>(torch.<span class="bu">abs</span>(torch.cat(data_list)),<span class="dv">0</span>)[<span class="dv">0</span>][<span class="dv">1</span>] )</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(label_list)):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        ax[i].set_title(label_list[i]) </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        ax[i].set_xlim([<span class="op">-</span>global_max, global_max]) </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        ax[i].set_ylim([<span class="op">-</span>global_max, global_max])</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">3</span>: <span class="co"># non-trajectory plots</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            ax[i].scatter( data_list[i][:, <span class="dv">0</span>], data_list[i][:, <span class="dv">1</span>], s<span class="op">=</span>size, alpha<span class="op">=</span>alpha, </span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>                          label<span class="op">=</span>label_list[i], color<span class="op">=</span>color_list[i])</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Plot trajectory paths first</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_viz):</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>                path <span class="op">=</span> trajectories[:, j]</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>                ax[<span class="dv">3</span>].plot(path[:, <span class="dv">0</span>], path[:, <span class="dv">1</span>], <span class="st">'-'</span>, color<span class="op">=</span>line_color, alpha<span class="op">=</span><span class="dv">1</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Then plot start and end points for the SAME trajectories</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>            start_points <span class="op">=</span> trajectories[<span class="dv">0</span>, :n_viz]</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>            end_points <span class="op">=</span> trajectories[<span class="op">-</span><span class="dv">1</span>, :n_viz]  </span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">3</span>].scatter(start_points[:, <span class="dv">0</span>], start_points[:, <span class="dv">1</span>], color<span class="op">=</span>source_color, s<span class="op">=</span>size, alpha<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Source Points'</span>)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">3</span>].scatter(end_points[:, <span class="dv">0</span>], end_points[:, <span class="dv">1</span>], color<span class="op">=</span>pred_color, s<span class="op">=</span>size, alpha<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Current Endpoints'</span>)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">3</span>].legend()</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the data</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>source_samples <span class="op">=</span> create_source_data(n_samples)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>target_samples <span class="op">=</span> create_target_data(n_samples)</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>val_points <span class="op">=</span> create_source_data(n_samples)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Testing visualization routines (before training):"</span>) </span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>viz(val_points, target_samples,  model) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Testing visualization routines (before training):</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-11-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The clever part about flow matching is how we train this network. For each training step:</p>
<ol type="1">
<li>Sample random points from our source distribution</li>
<li>Sample random time points between 0 and 1</li>
<li>Calculate where these points <em>should</em> be at those times (we’ll see how in a moment)</li>
<li>Calculate what velocity they <em>should</em> have at those times</li>
<li>Train the network to predict these velocities</li>
</ol>
<div class="cell">
<details>
<summary>Code for train_model() training loop</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_model(model, n_epochs<span class="op">=</span><span class="dv">100</span>, lr<span class="op">=</span><span class="fl">0.003</span>, batch_size<span class="op">=</span><span class="dv">2048</span>, status_every<span class="op">=</span><span class="dv">1</span>, viz_every<span class="op">=</span><span class="dv">1</span>, warp_fn<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span>lr)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    loss_fn <span class="op">=</span> nn.MSELoss()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    step, n_steps <span class="op">=</span> <span class="dv">0</span>, <span class="dv">100</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        model.train()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        pbar <span class="op">=</span> tqdm(<span class="bu">range</span>(n_steps), leave<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> pbar:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            step <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            <span class="co"># by randomly generating new data each step, we prevent the model from merely memorizing</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            source_samples <span class="op">=</span> create_source_data(batch_size).to(device)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            target_samples <span class="op">=</span> create_target_data(batch_size).to(device)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> torch.rand(source_samples.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device)  <span class="co"># random times for traning</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> warp_fn: t <span class="op">=</span> warp_fn(t)    <span class="co"># time warp is good for coverage but not as helpful for training as it is during integration/sampling</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            interpolated_samples <span class="op">=</span> source_samples <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> t) <span class="op">+</span> target_samples <span class="op">*</span> t</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            line_directions <span class="op">=</span> target_samples <span class="op">-</span> source_samples</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            drift <span class="op">=</span> model(interpolated_samples, t)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> loss_fn(drift, line_directions)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>            loss.backward()</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>            status_str <span class="op">=</span> <span class="ss">f'Epoch [</span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>n_epochs<span class="sc">}</span><span class="ss">], Loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">:.4f}</span><span class="ss">'</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>            pbar.set_description(status_str)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (epoch <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> viz_every <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>            model.<span class="bu">eval</span>()</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>            clear_output(wait<span class="op">=</span><span class="va">True</span>)  <span class="co"># Clear previous plots</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>            viz(val_points, target_samples[:val_points.shape[<span class="dv">0</span>]], model)</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>            plt.show()</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>            plt.close()  <span class="co"># Close the figure to free memory</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>            model.train()</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> epoch<span class="op">==</span>n_epochs<span class="op">-</span><span class="dv">1</span>: <span class="bu">print</span>(status_str)  <span class="co"># keep last status from being cleared</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>fm_model <span class="op">=</span> train_model(model, n_epochs<span class="op">=</span><span class="dv">100</span>)     <span class="co"># this will take a couple minutes</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-13-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch [100/100], Loss: 1.8636</code></pre>
</div>
</div>
<p>Here’s an animation of our model integrating the flow from start to finish:</p>
<div class="cell">
<details>
<summary>Code for animating points in flow</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.animation <span class="im">as</span> animation</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> HTML, display, clear_output</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> rc</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_flow_animation(start_dist, models, titles<span class="op">=</span><span class="va">None</span>, figsize<span class="op">=</span><span class="va">None</span>, n_frames<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                         step_fn<span class="op">=</span>fwd_euler_step, n_steps<span class="op">=</span><span class="dv">100</span>, warp_fn<span class="op">=</span><span class="va">None</span>, save_file<span class="op">=</span><span class="va">None</span>, height<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Create an animation showing multiple distribution flows</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">        start_dist: Starting distribution</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">        models: List of models to animate</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">        titles: List of titles for each subplot (optional)</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">        figsize: Figure size (optional)</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">        n_frames: Number of animation frames</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">        integrator: Integration function to use</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">        jitter: Amount of jitter to add</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co">        save_file: Path to save animation (optional)</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co">        height: Height of each subplot</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    plt.close(<span class="st">'all'</span>)  <span class="co"># Close all open figures</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(models, <span class="bu">list</span>): models <span class="op">=</span> [models]</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    n_plots <span class="op">=</span> <span class="bu">len</span>(models)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> titles <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>        titles <span class="op">=</span> [<span class="ss">f'Flow </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_plots)]</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">len</span>(titles) <span class="op">!=</span> n_plots:</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Number of titles (</span><span class="sc">{</span><span class="bu">len</span>(titles)<span class="sc">}</span><span class="ss">) must match number of models (</span><span class="sc">{</span>n_plots<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate figure size</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> figsize <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>        figsize <span class="op">=</span> [height <span class="op">*</span> n_plots, height]</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create subplots</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_plots, figsize<span class="op">=</span>figsize)</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_plots <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>        axes <span class="op">=</span> [axes]</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>    plt.close()  <span class="co"># Close the figure immediately</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize scatters and trajectories</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>    scatters <span class="op">=</span> []</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>    all_trajectories <span class="op">=</span> []</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate trajectories for each model</span></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">abs</span>(start_dist).<span class="bu">max</span>().item()</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, model <span class="kw">in</span> <span class="bu">enumerate</span>(models):</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>        device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>        end_dist, trajectories <span class="op">=</span> integrate_path(model, start_dist.clone().to(device), n_steps<span class="op">=</span>n_frames,  </span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>                                          step_fn<span class="op">=</span>step_fn, warp_fn<span class="op">=</span>warp_fn, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>        all_trajectories.append(trajectories.cpu())</span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>        scatters.append(axes[i].scatter([], [], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>wong_pink))</span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update max range</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>        max_range <span class="op">=</span> <span class="bu">max</span>(max_range, <span class="bu">abs</span>(end_dist.cpu()).<span class="bu">max</span>().item())</span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up axes</span></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axes):</span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a>        ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> spine <span class="kw">in</span> [<span class="st">'top'</span>, <span class="st">'right'</span>, <span class="st">'bottom'</span>, <span class="st">'left'</span>]:</span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a>            ax.spines[spine].set_visible(<span class="va">False</span>)</span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a>        ax.set_title(titles[i])</span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> init():</span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Initialize animation"""</span></span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> scatter <span class="kw">in</span> scatters:</span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a>            scatter.set_offsets(np.c_[[], []])</span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">tuple</span>(scatters)</span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> animate(frame):</span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Update animation frame"""</span></span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update axis limits (in case they need to be adjusted)</span></span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ax <span class="kw">in</span> axes:</span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true" tabindex="-1"></a>            ax.set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true" tabindex="-1"></a>            ax.set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-84"><a href="#cb13-84" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update scatter positions</span></span>
<span id="cb13-85"><a href="#cb13-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> scatter, trajectories <span class="kw">in</span> <span class="bu">zip</span>(scatters, all_trajectories):</span>
<span id="cb13-86"><a href="#cb13-86" aria-hidden="true" tabindex="-1"></a>            scatter.set_offsets(trajectories[frame].numpy())</span>
<span id="cb13-87"><a href="#cb13-87" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-88"><a href="#cb13-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">tuple</span>(scatters)</span>
<span id="cb13-89"><a href="#cb13-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-90"><a href="#cb13-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create animation</span></span>
<span id="cb13-91"><a href="#cb13-91" aria-hidden="true" tabindex="-1"></a>    anim <span class="op">=</span> animation.FuncAnimation(fig, animate, init_func<span class="op">=</span>init,</span>
<span id="cb13-92"><a href="#cb13-92" aria-hidden="true" tabindex="-1"></a>                                 frames<span class="op">=</span>n_frames, interval<span class="op">=</span><span class="dv">20</span>, blit<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-93"><a href="#cb13-93" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-94"><a href="#cb13-94" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle saving or displaying</span></span>
<span id="cb13-95"><a href="#cb13-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_file:</span>
<span id="cb13-96"><a href="#cb13-96" aria-hidden="true" tabindex="-1"></a>        os.makedirs(os.path.dirname(save_file), exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-97"><a href="#cb13-97" aria-hidden="true" tabindex="-1"></a>        anim.save(save_file, writer<span class="op">=</span><span class="st">'ffmpeg'</span>, fps<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb13-98"><a href="#cb13-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(<span class="ss">f"""&lt;center&gt;&lt;video height="350" controls loop&gt;&lt;source src="</span><span class="sc">{</span>anim_file<span class="sc">}</span><span class="ss">" type="video/mp4"&gt;</span></span>
<span id="cb13-99"><a href="#cb13-99" aria-hidden="true" tabindex="-1"></a><span class="ss">              Your browser does not support the video tag. &lt;/video&gt;&lt;/center&gt;"""</span>)</span>
<span id="cb13-100"><a href="#cb13-100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:  <span class="co"># direct matplotlib anim offers better controls but makes ipynb file size huge</span></span>
<span id="cb13-101"><a href="#cb13-101" aria-hidden="true" tabindex="-1"></a>        rc(<span class="st">'animation'</span>, html<span class="op">=</span><span class="st">'jshtml'</span>)</span>
<span id="cb13-102"><a href="#cb13-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(anim.to_jshtml())</span>
<span id="cb13-103"><a href="#cb13-103" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb13-104"><a href="#cb13-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-105"><a href="#cb13-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-106"><a href="#cb13-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-107"><a href="#cb13-107" aria-hidden="true" tabindex="-1"></a>anim_file <span class="op">=</span> <span class="st">'images/particles_fm.mp4'</span></span>
<span id="cb13-108"><a href="#cb13-108" aria-hidden="true" tabindex="-1"></a>create_flow_animation(val_points.clone(), models<span class="op">=</span>[fm_model], titles<span class="op">=</span>[<span class="st">'Flow Matching'</span>],</span>
<span id="cb13-109"><a href="#cb13-109" aria-hidden="true" tabindex="-1"></a>                      n_frames<span class="op">=</span><span class="dv">50</span>, save_file<span class="op">=</span>anim_file)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<center><video height="350" controls="" loop=""><source src="images/particles_fm.mp4" type="video/mp4">
              Your browser does not support the video tag. </video></center>
</div>
</div>
<p>So, even though we trained using trajectories that crossed, what the model learned were non-crossing (but curvy!) trajectories. Here’s a static plot of these:</p>
<div class="cell">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_training_trajectories_vs_learned_flow(model):</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>   <span class="co">"""Compare training trajectories with learned flow field"""</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>   plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>   <span class="co"># 1. Plot some training trajectories</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>   plt.subplot(<span class="dv">131</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>   n_trajs <span class="op">=</span> <span class="dv">50</span>  <span class="co"># Number of trajectories to show</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>   device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>   source <span class="op">=</span> create_gaussian_data(n_trajs)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>   target <span class="op">=</span> create_square_data(n_trajs)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>   current_points <span class="op">=</span> source.clone().to(device)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Plot straight-line trajectories from source to target</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>   times <span class="op">=</span> torch.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">20</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_trajs):</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>       traj <span class="op">=</span> source[i:i<span class="op">+</span><span class="dv">1</span>] <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> times.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">+</span> target[i:i<span class="op">+</span><span class="dv">1</span>] <span class="op">*</span> times.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>       plt.plot(traj[:, <span class="dv">0</span>], traj[:, <span class="dv">1</span>], <span class="st">'b-'</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>   plt.title(<span class="st">'Training Trajectories</span><span class="ch">\n</span><span class="st">(with crossings)'</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>   plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>   <span class="co"># 2. Plot learned flow field</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>   plt.subplot(<span class="dv">132</span>)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>   x <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>   y <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>   X, Y <span class="op">=</span> torch.meshgrid(x, y, indexing<span class="op">=</span><span class="st">'ij'</span>)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>   points <span class="op">=</span> torch.stack([X.flatten(), Y.flatten()], dim<span class="op">=</span><span class="dv">1</span>).to(device)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>   <span class="co"># with torch.no_grad():</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>   <span class="co">#     t =  0.5  # Show flow field at t=0.5</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>   <span class="co">#     ones = torch.ones(points.size(0), 1)</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>   ones <span class="op">=</span> torch.ones(points.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device)</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>   t <span class="op">=</span> ones <span class="op">*</span> (<span class="fl">0.5</span>)</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>   velocities <span class="op">=</span> model(points, t).cpu()</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>   <span class="co">#print("points.shape, ones.shape = ",points.shape, ones.shape) </span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>   <span class="co">#velocities = model(points, t*ones)</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>   points <span class="op">=</span> points.cpu()</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>   plt.quiver(points[:, <span class="dv">0</span>], points[:, <span class="dv">1</span>], </span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>             velocities[:, <span class="dv">0</span>], velocities[:, <span class="dv">1</span>],</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>             alpha<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span>line_color, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>   plt.title(<span class="st">'Learned Flow Field</span><span class="ch">\n</span><span class="st">at t=0.5'</span>)</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>   plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>   <span class="co"># 3. Plot actual paths taken using learned flow</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>   plt.subplot(<span class="dv">133</span>)</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>   source <span class="op">=</span> create_gaussian_data(n_trajs)</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Use RK4 to follow the learned flow</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>   paths <span class="op">=</span> []</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>   n_steps <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>   dt <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> n_steps</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>   <span class="cf">with</span> torch.no_grad():</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>       ones <span class="op">=</span> torch.ones(current_points.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device)</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>       <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>           paths.append(current_points.clone())</span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>           </span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a>           <span class="co"># RK4 step</span></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a>           t <span class="op">=</span> ones <span class="op">*</span> (i <span class="op">*</span> dt)</span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a>           k1 <span class="op">=</span> model(current_points, t)</span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a>           k2 <span class="op">=</span> model(current_points <span class="op">+</span> k1 <span class="op">*</span> dt<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>           k3 <span class="op">=</span> model(current_points <span class="op">+</span> k2 <span class="op">*</span> dt<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a>           k4 <span class="op">=</span> model(current_points <span class="op">+</span> k3 <span class="op">*</span> dt, t <span class="op">+</span> dt)</span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>           </span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a>           current_points <span class="op">=</span> current_points <span class="op">+</span> (k1 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k2 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k3 <span class="op">+</span> k4) <span class="op">*</span> dt<span class="op">/</span><span class="dv">6</span></span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a>   paths <span class="op">=</span> torch.stack(paths).cpu()</span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Plot the actual paths</span></span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_trajs):</span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a>       traj <span class="op">=</span> paths[:, i, :]</span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true" tabindex="-1"></a>       plt.plot(traj[:, <span class="dv">0</span>], traj[:, <span class="dv">1</span>], color<span class="op">=</span>line_color, alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true" tabindex="-1"></a>   plt.title(<span class="st">'Actual Paths</span><span class="ch">\n</span><span class="st">Following Learned Flow'</span>)</span>
<span id="cb14-76"><a href="#cb14-76" aria-hidden="true" tabindex="-1"></a>   plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb14-77"><a href="#cb14-77" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb14-78"><a href="#cb14-78" aria-hidden="true" tabindex="-1"></a>   plt.tight_layout()</span>
<span id="cb14-79"><a href="#cb14-79" aria-hidden="true" tabindex="-1"></a>   plt.savefig(<span class="st">'images/cross_uncross_plot.png'</span>)</span>
<span id="cb14-80"><a href="#cb14-80" aria-hidden="true" tabindex="-1"></a>   plt.show()</span>
<span id="cb14-81"><a href="#cb14-81" aria-hidden="true" tabindex="-1"></a>   plt.close()</span>
<span id="cb14-82"><a href="#cb14-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-83"><a href="#cb14-83" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the visualization</span></span>
<span id="cb14-84"><a href="#cb14-84" aria-hidden="true" tabindex="-1"></a>plot_training_trajectories_vs_learned_flow(fm_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>…So we see that even though the model was trained using lots of crossing paths, it learned a smooth flow from them!</p>
<p>Even though the trajectories on the right are smooth and non-crossing, their curviness means that we need to integrate slowly and carefully to avoid accruing significant error. Good news: the “Rectified Flow” paper of Liu et al <span class="citation" data-cites="rectified_flow"><a href="#ref-rectified_flow" role="doc-biblioref">[2]</a></span> offers a powerful way to speed up the integration by “straightening” the curved trajectories, a method they call “Reflow.”</p>
</section>
</section>
<section id="reflow-to-go-straighter-faster" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> “Reflow” to Go Straighter &amp; Faster</h1>
<p>The Reflow idea is that, instead of randomly pairing source and target points when choosing straight trajectories, we use “simulated target points” by integrating the source points forward using the learned flow model. Then we use those endpoints as the targets and assume linear motion as before.</p>
<p><img src="images/reflow_diagram.png" class="img-fluid"></p>
<p>This has the effect of straightening out the curved trajectory of the flow matching model, making the new “reflowed” trajectories much easier and faster to integrate!</p>
<p>Essentially, Reflow is a “teacher-student” paradigm in which the (pre-)trained flow-matching model is the teacher, and the new Reflowed model is the student. One can also think of this as a kind of distillation, akin to “consistency models” <span class="citation" data-cites="consistency_models"><a href="#ref-consistency_models" role="doc-biblioref">[8]</a></span>.</p>
<p>Before we can rely on those integrated endpoints, we should make a couple of improvements to how we use the model we just trained.</p>
<section id="upgrading-our-gear-first" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="upgrading-our-gear-first"><span class="header-section-number">3.1</span> Upgrading Our Gear First</h2>
<p>Neither of these upgrades require retraining the model. They just help to make more efficient, accurate use of it so it can serve as an effective “teacher” to the “student” Reflow model we’ll train below.</p>
<section id="more-points-where-needed-via-time-warping" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="more-points-where-needed-via-time-warping"><span class="header-section-number">3.1.1</span> More Points Where Needed (via Time Warping)</h3>
<p>You’ll notice that trajectories are sharply curved in the middle, but are straight near the start and end. Just as you’d slow down when driving around a sharp turn, we should take smaller integration steps in these curved regions for accuracy.</p>
<p>This idea of non-uniform temporal sampling appears throughout generative models. Esser et al.’s “FLUX” paper <span class="citation" data-cites="flux_paper"><a href="#ref-flux_paper" role="doc-biblioref">[1]</a></span> specifically designs their sampling distribution to concentrate points in the middle of the integration where accuracy is most crucial. The same principle applies here: during training, we need good coverage where the model needs to make careful predictions, and during inference, high-curvature regions require denser sampling.</p>
<p>One handy S-shaped time-warping function is this polynomial that lets us vary the concentration of points<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<p><span class="math display">\[ f(t) =  4(1-s)t^3 + 6(s-1) t^2 + (3-2s)t, \ \ \ \ \ \  t\in[0,1], \ \ \ s\in[0,3/2] \]</span></p>
<div class="cell">
<div class="cell-output cell-output-display">

<center>
<a href="https://www.desmos.com/calculator/g6ffbljlng">
<iframe src="https://www.desmos.com/calculator/hfjxlwycmz?embed" width="225" height="225" style="border: 1px solid #ccc" frameborder="0"></iframe>
<br>Interactive Desmos Graph Link</a>
<br><br>
</center></div>
</div>
<p>The parameter <span class="math inline">\(s\)</span> is the slope at t=1/2, and controls where points concentrate: values between 0 and 1 give us more points in the middle, which is exactly what we want for these curved trajectories. The value <span class="math inline">\(s=0.5\)</span> is a good choice, as we’ll see shortly.</p>
<p>This approach can improve accuracy and/or require fewer total integration steps. Let’s look at the results of different amounts of time-warping around a simple parabola:</p>
<div class="cell">
<details>
<summary>Show the code: warp_time function</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> warp_time(t, dt<span class="op">=</span><span class="va">None</span>, s<span class="op">=</span><span class="fl">.5</span>):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parametric Time Warping: s = slope in the middle. </span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">        s=1 is linear time, s &lt; 1 goes slower near the middle, s&gt;1 goes slower near the ends</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">        s = 1.5 gets very close to the "cosine schedule", i.e. (1-cos(pi*t))/2, i.e. sin^2(pi/2*x)"""</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> s<span class="op">&lt;</span><span class="dv">0</span> <span class="kw">or</span> s<span class="op">&gt;</span><span class="fl">1.5</span>: <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"s=</span><span class="sc">{</span>s<span class="sc">}</span><span class="ss"> is out of bounds."</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    tw <span class="op">=</span> <span class="dv">4</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>s)<span class="op">*</span>t<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">6</span><span class="op">*</span>(s<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span><span class="op">-</span><span class="dv">2</span><span class="op">*</span>s)<span class="op">*</span>t </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dt:                           <span class="co"># warped time-step requested; use derivative</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tw,  dt <span class="op">*</span> <span class="dv">12</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>s)<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">12</span><span class="op">*</span>(s<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>t <span class="op">+</span> (<span class="dv">3</span><span class="op">-</span><span class="dv">2</span><span class="op">*</span>s) </span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tw</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details>
<summary>viz code for parabolic path / variable dot-spacing figure</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>parab   <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">4</span><span class="op">*</span>(x<span class="op">-</span><span class="fl">0.5</span>)<span class="op">**</span><span class="dv">2</span>  <span class="co"># curve shape</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>d_parab <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">8</span><span class="op">*</span>(x<span class="op">-</span><span class="fl">0.5</span>)     <span class="co"># derivative</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>ds      <span class="op">=</span> <span class="kw">lambda</span> x: torch.sqrt(<span class="dv">1</span> <span class="op">+</span> d_parab(x)<span class="op">**</span><span class="dv">2</span>)  <span class="co"># differential arc length</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_total_arc_length(n<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the total arc length of the parabola y = 4(x - 0.5)**2 from x=0 to x=1"""</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    x_values <span class="op">=</span> torch.linspace(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    arc_length_values <span class="op">=</span> ds(x_values)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    total_arc_length <span class="op">=</span> torch.trapz(arc_length_values, x_values)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_arc_length</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fake_velocity_model(loc, t, speed<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""For demo purposes only: Follow a parabolic path and move at unit speed</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute the x and y components of the velocity along the parabola y = 4(x - 0.5)^2"""</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> loc[:, <span class="dv">0</span>], loc[:, <span class="dv">1</span>]    </span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    slope <span class="op">=</span> d_parab(x)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    direction <span class="op">=</span> torch.stack([torch.ones_like(slope), slope], dim<span class="op">=</span><span class="dv">1</span>)    </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    magnitude <span class="op">=</span> torch.norm(direction, dim<span class="op">=</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    unit_velocity <span class="op">=</span> direction <span class="op">/</span> magnitude    </span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> unit_velocity<span class="op">*</span>speed</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integrate_motion_along_parabola(</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        model, initial_points, n_steps<span class="op">=</span><span class="dv">30</span>, step_fn<span class="op">=</span>fwd_euler_step, s<span class="op">=</span><span class="fl">0.5</span>,):</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""one-off integrator used only for this one visualization figure. don't use for anything else"""</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    current_points <span class="op">=</span> initial_points.clone()</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    trajectories <span class="op">=</span> [current_points.cpu().clone()]</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    ts <span class="op">=</span> torch.linspace(<span class="dv">0</span>,<span class="fl">1.0</span>, n_steps) </span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    ts <span class="op">=</span> warp_time(ts, s<span class="op">=</span>s)                <span class="co"># here's the time worpage</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    speed <span class="op">=</span> calculate_total_arc_length()   <span class="co"># Total travel time is 1.0 so speed "=" distance</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    scaled_model <span class="op">=</span> partial(model, speed<span class="op">=</span>speed)</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>            current_points <span class="op">=</span> step_fn( scaled_model , current_points.clone(), ts[i],  ts[i<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>ts[i])</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>            trajectories.append(current_points.cpu().clone())</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack(trajectories)</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> viz_parabola_with_steps(step_fn<span class="op">=</span>fwd_euler_step, n_steps<span class="op">=</span><span class="dv">28</span>):</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""varies warp parameter s and integrates along a parabola"""</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    t_curve <span class="op">=</span> torch.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">100</span>)</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>    n_t_points <span class="op">=</span> n_steps <span class="co"># 28 if step_fn==fwd_euler_step else 6</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    t_points <span class="op">=</span> torch.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n_t_points)</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    n_s <span class="op">=</span> <span class="dv">6</span>    <span class="co"># number of different s values to show</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_s, figsize<span class="op">=</span>(n_s<span class="op">*</span><span class="fl">2.8</span>, <span class="dv">3</span>))</span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="ss">f"Integration scheme = </span><span class="sc">{</span>step_fn<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">"</span>, fontsize<span class="op">=</span><span class="dv">16</span>, y<span class="op">=</span><span class="fl">1.05</span>)</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    initial_points <span class="op">=</span> torch.tensor([[<span class="dv">0</span>,<span class="dv">1</span>]])                   <span class="co"># one point in the top left</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(torch.linspace(<span class="fl">.25</span>, <span class="fl">1.5</span>, n_s)):   <span class="co"># warp time by different amounts via s parameter</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>        ax[i].plot(t_curve, parab(t_curve))    <span class="co"># solid line showing path</span></span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>        traj <span class="op">=</span> integrate_motion_along_parabola(fake_velocity_model, initial_points, n_steps<span class="op">=</span>n_t_points, </span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">=</span>s, step_fn<span class="op">=</span>step_fn).squeeze() </span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>        err_str <span class="op">=</span> <span class="ss">f"</span><span class="ch">\n</span><span class="ss">error=</span><span class="sc">{</span>F<span class="sc">.</span>mse_loss(parab(traj[:,<span class="dv">0</span>]),traj[:,<span class="dv">1</span>])<span class="sc">:.3g}</span><span class="ss">"</span></span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>        ax[i].scatter(traj[:,<span class="dv">0</span>], traj[:,<span class="dv">1</span>], label<span class="op">=</span><span class="ss">f's = </span><span class="sc">{</span>s<span class="sc">:.2f}{</span>err_str<span class="sc">}</span><span class="ss">'</span>, color<span class="op">=</span>(wong_cmap<span class="op">*</span><span class="dv">2</span>)[i])</span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>        legend <span class="op">=</span> ax[i].legend(loc<span class="op">=</span><span class="st">'upper center'</span>, frameon<span class="op">=</span><span class="va">False</span>, markerscale<span class="op">=</span><span class="dv">0</span>, handlelength<span class="op">=</span><span class="dv">0</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> text <span class="kw">in</span> legend.get_texts():</span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>            text.set_ha(<span class="st">'center'</span>)</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(s<span class="op">-</span><span class="fl">1.0</span>) <span class="op">&lt;</span> <span class="fl">1e-3</span>: ax[i].set_title(<span class="st">'Even Spacing'</span>) </span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].set_title(<span class="st">'More Points in Middle'</span>)</span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>    ax[<span class="op">-</span><span class="dv">1</span>].set_title(<span class="st">'More Points at Ends'</span>)</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a>viz_parabola_with_steps() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-18-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>While the results for <span class="math inline">\(s=0.5\)</span> are better than the others, we see that <em>none</em> of these examples make it all the way around the parabola (to the point (1,1))! If we’re going to be using the flow matching model as a proxy for the true target data, we should have some confidence that it’s actually “getting to” the target data. We could add more points to the integration, but there’s another way: upgrade the integration (i.e.&nbsp;sampling) operation to a higher order of accuracy.</p>
</section>
<section id="better-integration-sampling" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="better-integration-sampling"><span class="header-section-number">3.1.2</span> Better Integration / Sampling</h3>
<p>While forward Euler is surprisingly popular in ML circles, those with simulation backgrounds eye it with suspicion: despite being fast and easy to implement, it’s also highly inaccurate and can lead to instabilities. The poor accuracy may not be an issue when everything’s an approximation anyway, but we can do a lot better.</p>
<p>People who work with diffusion models know this, e.g.&nbsp;in <a href="https://github.com/crowsonkb/k-diffusion">Katherine Crowson’s k-diffusion package</a> offers a bevy of integration choices. For here we’ll just implement the popular 4th-order Runge-Kutta (RK4) scheme. It’s more “expensive” than forward Euler in that each step requires 4 function evaluations instead of forward Euler’s 1 step, and it requires some extra storage, but the advantages you gain in accuracy are seriously worth it (e.g., because you can take much longer steps in time).</p>
<div class="cell">
<details>
<summary>Code for 4th-order Runge-Kutta integration</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rk4_step(f, <span class="co"># function that takes (t,y) and returns dy/dt, i.e. velocity</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>             y, <span class="co"># current location</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>             t, <span class="co"># current t value</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>             dt, <span class="co"># requested time step size </span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>             ):</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span>  f(y, t)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    k2 <span class="op">=</span>  f(y <span class="op">+</span> dt<span class="op">*</span>k1<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>) </span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    k3 <span class="op">=</span>  f(y <span class="op">+</span> dt<span class="op">*</span>k2<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>) </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    k4 <span class="op">=</span>  f(y <span class="op">+</span> dt<span class="op">*</span>k3, t <span class="op">+</span> dt) </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y <span class="op">+</span> (dt<span class="op">/</span><span class="dv">6</span>)<span class="op">*</span>(k1 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k2 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k3 <span class="op">+</span> k4)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>viz_parabola_with_steps(step_fn<span class="op">=</span>rk4_step, n_steps<span class="op">=</span><span class="dv">6</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>It’s cool how the RK4 results, despite showing less error than the Euler results, actually involve <em>less</em> computational cost in terms of number of function evaluations, though the RK4 scheme needs 4 times the storage compared to forward Euler. (The good news is that no PyTorch gradients need to be stored; the integrator is only ever used when the model is in “eval” mode.)</p>
</section>
</section>
<section id="learning-to-reflow" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="learning-to-reflow"><span class="header-section-number">3.2</span> Learning to “ReFlow”</h2>
<p>When we train the “Reflowed” model, aka the student model, note that the “target data” will no longer be supplied by the true target data anymore. Rather, we will be using the trajectory endpoints integrated/generated using the teacher model, i.e.&nbsp;the pretrained flow matching model.</p>
<p>So we might ask… how close of an approximation are those learned flow endpoints to the real thing? We’re going to be approximating an approximation, but how good is the original approximation?</p>
<p>Let’s take a look…</p>
<div class="cell">
<details>
<summary>quick check of how our flow endpoints are looking</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>pretrained_model <span class="op">=</span> fm_model </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>pretrained_model.<span class="bu">eval</span>()</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>reflow_targets <span class="op">=</span> integrate_path(pretrained_model, val_points.to(device), n_steps<span class="op">=</span><span class="dv">8</span>, step_fn<span class="op">=</span>rk4_step, warp_fn<span class="op">=</span>warp_time).cpu()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">3</span>))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, [data, color, label] <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>([val_points,   reflow_targets, target_samples], </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                                             [source_color, pred_color,     target_color],</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                                             [<span class="st">'Source Data'</span>, <span class="st">'Learned Flow Endpoints'</span>, <span class="st">'True Target Data'</span>])):</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    ax[i].scatter(data[:,<span class="dv">0</span>], data[:,<span class="dv">1</span>], color<span class="op">=</span>color, label<span class="op">=</span>label, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    ax[i].set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(label)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-20-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>….ok, so we see the learned outputs are a bit different from the true data, but they’re not bad. Let’s now train the “reflow” model.</p>
<section id="train-the-reflowed-model" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="train-the-reflowed-model"><span class="header-section-number">3.2.1</span> Train the Reflowed Model</h3>
<p>There’s one small but crucial change from the previous training code to this one, namely what we use as target data:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">##  target_samples = create_target_data(batch_size)           # Previous "random pairing"</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>target_samples <span class="op">=</span> integrator(pretrained_model, source_samples) <span class="co"># Reflow!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell">
<details>
<summary>Code for the new training loop w/ ReFlowed targets</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_reflow_model(model, pretrained_model<span class="op">=</span><span class="va">None</span>, </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>                          n_epochs<span class="op">=</span><span class="dv">40</span>, lr<span class="op">=</span><span class="fl">0.001</span>, batch_size<span class="op">=</span><span class="dv">2048</span>, </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>                          status_every<span class="op">=</span><span class="dv">1</span>, viz_every<span class="op">=</span><span class="dv">1</span>, <span class="co"># in epochs</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>                          new_points_every<span class="op">=</span><span class="dv">1</span>, <span class="co"># in steps </span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>                          warp_fn<span class="op">=</span>warp_time, </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>                          step_fn<span class="op">=</span>rk4_step, <span class="co"># rk4 so we get high-quality outputs while reflowing</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>                          ):</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""This is almost IDENTICAL to the previous training routine. </span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">        The difference is the change in "target_samples" via what the RF authors call "ReFlow": </span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">        Instead of (randomly) paring source points with points in the "true target distribution", </span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">        we use the pretrained/teacher model to integrate the source points to their (predicted) flow endpoints </span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co">        and use THOSE as the "target" values.</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span>lr)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    loss_fn <span class="op">=</span> nn.MSELoss()</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    step, n_steps <span class="op">=</span> <span class="dv">0</span>, <span class="dv">100</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        model.train()</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        pbar <span class="op">=</span> tqdm(<span class="bu">range</span>(n_steps), leave<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> pbar:</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>            step <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> step <span class="op">%</span> new_points_every <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># you could in theory not draw new points with each step, though we will. </span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>                source_samples <span class="op">=</span> create_source_data(batch_size).to(device)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pretrained_model:   <span class="co"># HERE is the ReFlow operation...</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>                    target_samples <span class="op">=</span> integrate_path(pretrained_model, source_samples, step_fn<span class="op">=</span>rk4_step, warp_fn<span class="op">=</span>warp_time, n_steps<span class="op">=</span><span class="dv">20</span>)  </span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>                    target_samples <span class="op">=</span> create_target_data(batch_size) <span class="co"># this function also supports fm models from scratch</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> torch.rand(source_samples.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device) <span class="co"># random times for training</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> warp_fn: t <span class="op">=</span> warp_fn(t)  <span class="co"># time warp here (different from use in integrator!) helps focus "coverage" i.e. sampling the space</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>            interpolated_samples <span class="op">=</span> source_samples <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> t) <span class="op">+</span> target_samples <span class="op">*</span> t            </span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> model(interpolated_samples, t)</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>            line_directions <span class="op">=</span> target_samples <span class="op">-</span> source_samples </span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> loss_fn(v, line_directions)</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>            loss.backward()</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>            pbar.set_description(<span class="ss">f'Epoch [</span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>n_epochs<span class="sc">}</span><span class="ss">], Loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">:.4g}</span><span class="ss">'</span>)</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (epoch <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> viz_every <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>            model.<span class="bu">eval</span>()</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>            clear_output(wait<span class="op">=</span><span class="va">True</span>)  <span class="co"># Clear previous plots</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>            viz(val_points, target_samples[:val_points.shape[<span class="dv">0</span>]], model)  <span class="co"># don't need rk4 for rect model viz b/c paths r straight</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>            plt.show()</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>            plt.close()  <span class="co"># Close the figure to free memory</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>            model.train()</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> copy</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>reflowed_model <span class="op">=</span> copy.deepcopy(pretrained_model) <span class="co"># no need to train student from scratch, start from teacher's weights</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>reflowed_model.train()</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>reflowed_model <span class="op">=</span> train_reflow_model(reflowed_model, pretrained_model<span class="op">=</span>pretrained_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="FlowModels_files/figure-html/cell-22-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Oooo, look how straight the trajectories are now! Let’s compare animations of the original flow matching model with the “Reflowed” model:</p>
<div class="cell">
<details>
<summary>Making movie for particle animation comparison</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>rect_eval <span class="op">=</span> reflowed_model.<span class="bu">eval</span>()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>anim_file <span class="op">=</span> <span class="st">"images/particles_fm_vs_rf.mp4"</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>create_flow_animation(val_points.clone(), models<span class="op">=</span>[pretrained_model, reflowed_model], </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        n_frames<span class="op">=</span><span class="dv">50</span>, titles<span class="op">=</span>[<span class="st">'Flow Matching'</span>,<span class="st">'Reflowed Flow'</span>], save_file<span class="op">=</span>anim_file)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<center><video height="350" controls="" loop=""><source src="images/particles_fm_vs_rf.mp4" type="video/mp4">
              Your browser does not support the video tag. </video></center>
</div>
</div>
<p>Notice how the flow matching trajectories on the left have the data moving inward a ways and then back out, whereas the reflowed trajectories move directly from start to finish with no backtracking.</p>
<p>The next movie shows an animation of “streamlines” with arrows for the local vector field. Note how the shapes on the right change very little over time compared to those on the left. We’ll say a bit more about that below.</p>
<div class="cell">
<details>
<summary>Code for streamline animation</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_streamline_animation(start_dist, model, model2<span class="op">=</span><span class="va">None</span>, n_frames<span class="op">=</span><span class="dv">50</span>, show_points<span class="op">=</span><span class="va">False</span>, titles<span class="op">=</span><span class="va">None</span>, </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>                                step_fn<span class="op">=</span>fwd_euler_step,  <span class="co"># euler's ok for reflowed model bc/paths are straight</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                                save_file<span class="op">=</span><span class="va">None</span>, </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                               ):</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create an animation showing distribution flow with streamplot background"""</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    figsize <span class="op">=</span> [<span class="dv">5</span>,<span class="dv">5</span>]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> titles <span class="kw">is</span> <span class="va">None</span>: </span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        titles <span class="op">=</span> [<span class="st">'Flow Matching'</span>]</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2: titles <span class="op">+=</span> [<span class="st">'Reflowed Model'</span>]</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model2: </span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        figsize[<span class="dv">0</span>] <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    n_plots <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> (model2 <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_plots, figsize<span class="op">=</span>figsize)</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_plots<span class="op">==</span><span class="dv">1</span>: ax <span class="op">=</span> [ax]</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    end_dist, trajectories <span class="op">=</span> integrate_path(model, start_dist.clone().to(device), n_steps<span class="op">=</span>n_frames, step_fn<span class="op">=</span>step_fn, warp_fn<span class="op">=</span>warp_time, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    scatter <span class="op">=</span> ax[<span class="dv">0</span>].scatter([], [], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>wong_pink, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model2: </span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        _, trajectories2 <span class="op">=</span> integrate_path(model2, start_dist.clone().to(device), n_steps<span class="op">=</span>n_frames, step_fn<span class="op">=</span>step_fn, warp_fn<span class="op">=</span>warp_time, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>        scatter2 <span class="op">=</span> ax[<span class="dv">1</span>].scatter([], [], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>wong_pink, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">max</span>( <span class="bu">abs</span>(start_dist).<span class="bu">max</span>().item(), <span class="bu">abs</span>(end_dist).<span class="bu">max</span>().item() )</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ax)):</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>        ax[i].set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>        ax[i].set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>        ax[i].set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> titles: ax[i].set_title(titles[i])</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create grid for streamplot</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    grid_dim <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, grid_dim)</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, grid_dim)</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    X, Y <span class="op">=</span> np.meshgrid(x, y)</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert grid to torch tensor for model input</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>    grid_points <span class="op">=</span> torch.tensor(np.stack([X.flatten(), Y.flatten()], axis<span class="op">=</span><span class="dv">1</span>), dtype<span class="op">=</span>torch.float32).to(device)</span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> wong_pink <span class="cf">if</span> show_points <span class="cf">else</span> (<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>) </span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> n_frames </span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> init():</span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ax)):</span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>            ax[i].clear()</span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>            ax[i].set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>            ax[i].set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>        scatter.set_offsets(np.c_[[], []])</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2:</span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>                scatter.set_offsets(np.c_[[], []])</span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (scatter,scatter2)</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (scatter,)</span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> animate(frame):</span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ax)):</span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a>            ax[i].clear()</span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a>            ax[i].set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a>            ax[i].set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> titles: ax[i].set_title(titles[i])</span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a>            ax[i].set_xticks([])</span>
<span id="cb23-64"><a href="#cb23-64" aria-hidden="true" tabindex="-1"></a>            ax[i].set_yticks([])</span>
<span id="cb23-65"><a href="#cb23-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> spine <span class="kw">in</span> [<span class="st">'top'</span>,<span class="st">'right'</span>,<span class="st">'bottom'</span>,<span class="st">'left'</span>]:</span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a>                ax[i].spines[spine].set_visible(<span class="va">False</span>)</span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update scatter plot</span></span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> trajectories[frame]</span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a>        scatter <span class="op">=</span> ax[<span class="dv">0</span>].scatter(current[:, <span class="dv">0</span>], current[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>color, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2:</span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a>            current2 <span class="op">=</span> trajectories2[frame]</span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a>            scatter2 <span class="op">=</span> ax[i].scatter(current2[:, <span class="dv">0</span>], current2[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>color, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate vector field for current time</span></span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> torch.ones(grid_points.size(<span class="dv">0</span>), <span class="dv">1</span>) <span class="op">*</span> (frame <span class="op">*</span> dt)</span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> warp_time(t).to(device) </span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a>        velocities <span class="op">=</span> model(grid_points, t).cpu()</span>
<span id="cb23-79"><a href="#cb23-79" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> velocities[:, <span class="dv">0</span>].reshape(X.shape)</span>
<span id="cb23-80"><a href="#cb23-80" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> velocities[:, <span class="dv">1</span>].reshape(X.shape)</span>
<span id="cb23-81"><a href="#cb23-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-82"><a href="#cb23-82" aria-hidden="true" tabindex="-1"></a>        x_points <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, <span class="dv">15</span>)</span>
<span id="cb23-83"><a href="#cb23-83" aria-hidden="true" tabindex="-1"></a>        y_points <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, <span class="dv">15</span>)</span>
<span id="cb23-84"><a href="#cb23-84" aria-hidden="true" tabindex="-1"></a>        X_arrows, Y_arrows <span class="op">=</span> np.meshgrid(x_points, y_points)</span>
<span id="cb23-85"><a href="#cb23-85" aria-hidden="true" tabindex="-1"></a>        start_points <span class="op">=</span> np.column_stack((X_arrows.ravel(), Y_arrows.ravel()))</span>
<span id="cb23-86"><a href="#cb23-86" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].streamplot(X, Y, U.numpy(), V.numpy(),</span>
<span id="cb23-87"><a href="#cb23-87" aria-hidden="true" tabindex="-1"></a>             density<span class="op">=</span><span class="dv">5</span>,  <span class="co"># Controls line spacing</span></span>
<span id="cb23-88"><a href="#cb23-88" aria-hidden="true" tabindex="-1"></a>             color<span class="op">=</span>line_color, <span class="co"># (0, 0, 1, 0.7),</span></span>
<span id="cb23-89"><a href="#cb23-89" aria-hidden="true" tabindex="-1"></a>             linewidth<span class="op">=</span><span class="fl">0.8</span>, maxlength<span class="op">=</span><span class="fl">0.12</span>,</span>
<span id="cb23-90"><a href="#cb23-90" aria-hidden="true" tabindex="-1"></a>             start_points<span class="op">=</span>start_points,  <span class="co"># This should give more arrows along paths</span></span>
<span id="cb23-91"><a href="#cb23-91" aria-hidden="true" tabindex="-1"></a>             arrowsize<span class="op">=</span><span class="fl">1.2</span>,</span>
<span id="cb23-92"><a href="#cb23-92" aria-hidden="true" tabindex="-1"></a>             arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>)  </span>
<span id="cb23-93"><a href="#cb23-93" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-94"><a href="#cb23-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2: </span>
<span id="cb23-95"><a href="#cb23-95" aria-hidden="true" tabindex="-1"></a>            velocities2 <span class="op">=</span> model2(grid_points, t).cpu()</span>
<span id="cb23-96"><a href="#cb23-96" aria-hidden="true" tabindex="-1"></a>            U2 <span class="op">=</span> velocities2[:, <span class="dv">0</span>].reshape(X.shape)</span>
<span id="cb23-97"><a href="#cb23-97" aria-hidden="true" tabindex="-1"></a>            V2 <span class="op">=</span> velocities2[:, <span class="dv">1</span>].reshape(X.shape)</span>
<span id="cb23-98"><a href="#cb23-98" aria-hidden="true" tabindex="-1"></a>            start_points2 <span class="op">=</span> np.column_stack((X_arrows.ravel(), Y_arrows.ravel()))</span>
<span id="cb23-99"><a href="#cb23-99" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">1</span>].streamplot(X, Y, U2.numpy(), V2.numpy(),</span>
<span id="cb23-100"><a href="#cb23-100" aria-hidden="true" tabindex="-1"></a>                 density<span class="op">=</span><span class="dv">5</span>,  <span class="co"># Controls line spacing</span></span>
<span id="cb23-101"><a href="#cb23-101" aria-hidden="true" tabindex="-1"></a>                 color<span class="op">=</span>line_color, <span class="co"># (0, 0, 1, 0.7),</span></span>
<span id="cb23-102"><a href="#cb23-102" aria-hidden="true" tabindex="-1"></a>                 linewidth<span class="op">=</span><span class="fl">0.8</span>, maxlength<span class="op">=</span><span class="fl">0.12</span>,</span>
<span id="cb23-103"><a href="#cb23-103" aria-hidden="true" tabindex="-1"></a>                 start_points<span class="op">=</span>start_points2,  <span class="co"># This should give more arrows along paths</span></span>
<span id="cb23-104"><a href="#cb23-104" aria-hidden="true" tabindex="-1"></a>                 arrowsize<span class="op">=</span><span class="fl">1.2</span>,</span>
<span id="cb23-105"><a href="#cb23-105" aria-hidden="true" tabindex="-1"></a>                 arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>) </span>
<span id="cb23-106"><a href="#cb23-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-107"><a href="#cb23-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-108"><a href="#cb23-108" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update particle positions</span></span>
<span id="cb23-109"><a href="#cb23-109" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> torch.ones(current.size(<span class="dv">0</span>), <span class="dv">1</span>) <span class="op">*</span> (frame <span class="op">*</span> dt)</span>
<span id="cb23-110"><a href="#cb23-110" aria-hidden="true" tabindex="-1"></a>        t, dtw <span class="op">=</span> warp_time(t, dt<span class="op">=</span>dt)</span>
<span id="cb23-111"><a href="#cb23-111" aria-hidden="true" tabindex="-1"></a>        velocity <span class="op">=</span> model(current.to(device), t.to(device)).cpu()</span>
<span id="cb23-112"><a href="#cb23-112" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> current <span class="op">+</span> velocity <span class="op">*</span> dtw</span>
<span id="cb23-113"><a href="#cb23-113" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2: </span>
<span id="cb23-114"><a href="#cb23-114" aria-hidden="true" tabindex="-1"></a>            velocity2 <span class="op">=</span> model2(current2.to(device), t.to(device)).cpu()</span>
<span id="cb23-115"><a href="#cb23-115" aria-hidden="true" tabindex="-1"></a>            current2 <span class="op">=</span> current2 <span class="op">+</span> velocity2 <span class="op">*</span> dtw</span>
<span id="cb23-116"><a href="#cb23-116" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (scatter, scatter2,)</span>
<span id="cb23-117"><a href="#cb23-117" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (scatter,)</span>
<span id="cb23-118"><a href="#cb23-118" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-119"><a href="#cb23-119" aria-hidden="true" tabindex="-1"></a>    anim <span class="op">=</span> animation.FuncAnimation(fig, animate, init_func<span class="op">=</span>init,</span>
<span id="cb23-120"><a href="#cb23-120" aria-hidden="true" tabindex="-1"></a>                                 frames<span class="op">=</span>n_frames, interval<span class="op">=</span><span class="dv">20</span>, blit<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb23-121"><a href="#cb23-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-122"><a href="#cb23-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_file:</span>
<span id="cb23-123"><a href="#cb23-123" aria-hidden="true" tabindex="-1"></a>        anim.save(save_file, writer<span class="op">=</span><span class="st">'ffmpeg'</span>, fps<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb23-124"><a href="#cb23-124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(<span class="ss">f"""&lt;center&gt;&lt;video height="350" controls loop&gt;&lt;source src="</span><span class="sc">{</span>save_file<span class="sc">}</span><span class="ss">" type="video/mp4"&gt;</span></span>
<span id="cb23-125"><a href="#cb23-125" aria-hidden="true" tabindex="-1"></a><span class="ss">                      Your browser does not support the video tag.&lt;/video&gt;&lt;/center&gt;"""</span>)</span>
<span id="cb23-126"><a href="#cb23-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb23-127"><a href="#cb23-127" aria-hidden="true" tabindex="-1"></a>        rc(<span class="st">'animation'</span>, html<span class="op">=</span><span class="st">'jshtml'</span>)</span>
<span id="cb23-128"><a href="#cb23-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(anim.to_jshtml())</span>
<span id="cb23-129"><a href="#cb23-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-130"><a href="#cb23-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-131"><a href="#cb23-131" aria-hidden="true" tabindex="-1"></a>save_file <span class="op">=</span> <span class="st">'images/fm_vs_rf_streamvecs.mp4'</span></span>
<span id="cb23-132"><a href="#cb23-132" aria-hidden="true" tabindex="-1"></a>create_streamline_animation(val_points, fm_model, model2<span class="op">=</span>reflowed_model, n_frames<span class="op">=</span><span class="dv">50</span>, save_file<span class="op">=</span>save_file)<span class="co">#, show_points=True)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<center><video height="350" controls="" loop=""><source src="images/fm_vs_rf_streamvecs.mp4" type="video/mp4">
                      Your browser does not support the video tag.</video></center>
</div>
</div>
</section>
</section>
</section>
<section id="connecting-with-other-models" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Connecting with Other Models</h1>
<section id="from-dots-to-images-audio-etc.." class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="from-dots-to-images-audio-etc.."><span class="header-section-number">4.1</span> From Dots to Images, Audio, etc..</h2>
<p>How to move on from 2D dots to things like images, text, audio,…etc? We need only consider that the dimensionality of the velocity model is the same as that of the data itself. Put differently, one can regard the velocity model as supplying a tiny “change” to the data, whatever form that data is in. And the “straight line” trajectory used during training? That’s just linear interpolation between the (initially randomly-paired) source data and the target data. So for images, we will get a “velocity image”, which will tell us how to change the R,G,B values of every pixel in an image. This is where U-Nets and Attention come into play, to compute the “image-to-image” task of supplying a “velocity image” given an input image distribution (which may just be noise). For audio, regardless of the representation, the velocity model will tell us how to slightly change the component values in that representation. We then just integrate all the little changes as we did with the dots.</p>
<ul>
<li>I recommend checking out an MNIST image example such as Tadao Yamaoka’s <span class="citation" data-cites="rf_mnist_example"><a href="#ref-rf_mnist_example" role="doc-biblioref">[9]</a></span></li>
</ul>
</section>
<section id="diffusion-models" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="diffusion-models"><span class="header-section-number">4.2</span> Diffusion Models</h2>
<p>Diffusion models, aka “score-based models” are similar to flow models in that the former also learn a vector field (the “score function”) that serves to differentially transform the points in the sample. The difference is that flow models are deterministic, whereas diffusion models are constantly injecting fresh noise, as if they are simulating actual Brownian motion <span class="citation" data-cites="brownian_motion"><a href="#ref-brownian_motion" role="doc-biblioref">[7]</a></span> rather than the macroscopic flow. To turn our flow model into a diffusion model, we could add “jitter,” i.e.&nbsp;inject noise at every step. The variance of that jitter as a function of time would correspond directly to the “noise schedule” of diffusion models.<br>
<!-- There's a lot more than can be said (and has been said) about the many connections between diffusion models and flow-based models, but for brevity's sake we'll move on for now. --></p>
</section>
<section id="optimal-transport" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="optimal-transport"><span class="header-section-number">4.3</span> Optimal Transport</h2>
<p>Interesting observation: See how the Reflowed streamlines in the last movie are approximately stationary (i.e., time-independent)? This connects nicely with Optimal Transport theory, where the Benamou-Brenier formulation <span class="citation" data-cites="bb_form"><a href="#ref-bb_form" role="doc-biblioref">[10]</a></span> (which has a diffusion-esque equation as on objective) shows that optimal mass transport paths follow constant-velocity geodesics in the Wasserstein metric space. This time-independence property emerges naturally when minimizing transport costs in simple metric spaces, as particles following straight-line paths at constant speeds achieve optimal transport between distributions.</p>
</section>
<section id="normalizing-flows" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="normalizing-flows"><span class="header-section-number">4.4</span> Normalizing Flows</h2>
<p>Normalizing flows have the property that they preserve overall probability throughout the flow process. While this would seem to be a nice constraint to satisfy, it appears to be unnecessary for “getting the job done” yet it can limit the expressiveness of the model compared to the kinds of flows we’ve been talking about in this post. Note: Since I’m pushing a “physics perspective,” a similar “conservation” property arises in the phase space flows of Hamiltonian mechanics, namely that they preserve areas and volumes via Liousville’s Theorem <span class="citation" data-cites="liouvilles_theorem"><a href="#ref-liouvilles_theorem" role="doc-biblioref">[11]</a></span>. The connection between normalizing flows and Hamiltonian systems was applied to generative modeling in the “Neural Hamiltonian Flows” paper of ICLR 2020 <span class="citation" data-cites="Toth2020Hamiltonian"><a href="#ref-Toth2020Hamiltonian" role="doc-biblioref">[12]</a></span>, and continues in a recent NeurIPS 2024 poster-paper <span class="citation" data-cites="hamiltonian_flows"><a href="#ref-hamiltonian_flows" role="doc-biblioref">[13]</a></span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Despite these fascinating connections, the exciting thing about flow-matching and rectified flows is that they seem to be effective even in the absence of the explicit conservation properties of normalizing flows and their relatives, and can thus be implemented quickly and simply.</p>
</section>
</section>
<section id="summary" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Summary</h1>
<p>We’ve seen that flow matching and rectified flow models can be conceptualized and even developed using some simple ideas from basic physics. This simplicity, coupled with their power and flexibility have fueled their popularity and even rise to state-of-the-art levels.</p>
<p>Hopefully, after having read this, you will be able to better follow the rapid progress in flow-based generative AI in terms of both scholarly and industry output, as well as to have the confidence to expand on these ideas for your own investigations!</p>
</section>
<section id="references" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> References</h1>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-flux_paper" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">P. Esser <em>et al.</em>, <span>“Scaling rectified flow transformers for high-resolution image synthesis,”</span> in <em>41st <span>I</span>nternational <span>C</span>onference on <span>M</span>achine <span>L</span>earning, <span>ICML</span></em>, Vienna, Austria, 2024. Available: <a href="https://openreview.net/forum?id=FPnUhsQJ5B">https://openreview.net/forum?id=FPnUhsQJ5B</a></div>
</div>
<div id="ref-rectified_flow" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">X. Liu, C. Gong, and Q. Liu, <span>“Flow straight and fast: Learning to generate and transfer data with rectified flow,”</span> in <em>11th <span>I</span>nternational <span>C</span>onference on <span>L</span>earning <span>R</span>epresentations (ICLR)</em>, 2023. Available: <a href="https://openreview.net/forum?id=XVjTT1nw5z">https://openreview.net/forum?id=XVjTT1nw5z</a></div>
</div>
<div id="ref-improving_rf" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">S. Lee, Z. Lin, and G. Fanti, <span>“Improving the training of rectified flows.”</span> 2024. Available: <a href="https://arxiv.org/abs/2405.20320">https://arxiv.org/abs/2405.20320</a></div>
</div>
<div id="ref-jia_bin" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">J.-B. Huang, <span>“How <span>I</span> understand flow matching.”</span> YouTube, 2024. Available: <a href="https://www.youtube.com/watch?v=DDq_pIfHqLs">https://www.youtube.com/watch?v=DDq_pIfHqLs</a></div>
</div>
<div id="ref-mj_siggraph" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">T. Beier and S. Neely, <span>“Feature-based image metamorphosis,”</span> <em>ACM SIGGRAPH Comput. Graph.</em>, vol. 26, no. 2, pp. 35–42, Jul. 1992, doi: <a href="https://doi.org/10.1145/142920.134003">10.1145/142920.134003</a>.</div>
</div>
<div id="ref-tanishq_same" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">T. M. Abraham, <span>“"Flow matching and rectified flows are the same.”</span> X.com, 2024. Available: <a href="https://x.com/iScienceLuvr/status/1766700945243881889">https://x.com/iScienceLuvr/status/1766700945243881889</a></div>
</div>
<div id="ref-brownian_motion" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline"><span>“<span>B</span>rownian motion - <span>W</span>ikipedia — en.wikipedia.org.”</span> <a href="https://en.wikipedia.org/wiki/Brownian_motion" class="uri">https://en.wikipedia.org/wiki/Brownian_motion</a>.</div>
</div>
<div id="ref-consistency_models" class="csl-entry" role="listitem">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">Y. Song, P. Dhariwal, M. Chen, and I. Sutskever, <span>“Consistency models.”</span> 2023. Available: <a href="https://arxiv.org/abs/2303.01469">https://arxiv.org/abs/2303.01469</a></div>
</div>
<div id="ref-rf_mnist_example" class="csl-entry" role="listitem">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">T. Yamaoka, <span>“Image generation with rectified flow part 2 (learning MNIST using scratch implementation).”</span> 2024. Available: <a href="https://tadaoyamaoka.hatenablog.com/entry/2024/09/29/163801">https://tadaoyamaoka.hatenablog.com/entry/2024/09/29/163801</a></div>
</div>
<div id="ref-bb_form" class="csl-entry" role="listitem">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">J.-D. Benamou and Y. Brenier, <span>“A computational fluid mechanics solution to the <span>M</span>onge-<span>K</span>antorovich mass transfer problem,”</span> <em>Numerische Mathematik</em>, vol. 84, pp. 375–393, 2000, Available: <a href="https://api.semanticscholar.org/CorpusID:1100384">https://api.semanticscholar.org/CorpusID:1100384</a></div>
</div>
<div id="ref-liouvilles_theorem" class="csl-entry" role="listitem">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">Wikipedia, <span>“<span class="nocase">Liouville’s theorem (Hamiltonian)</span> — <span>W</span>ikipedia<span>,</span> the free encyclopedia.”</span> <a href="http://en.wikipedia.org/w/index.php?title=Liouville's%20theorem%20(Hamiltonian)&amp;oldid=1233185478" class="uri">http://en.wikipedia.org/w/index.php?title=Liouville's%20theorem%20(Hamiltonian)&amp;oldid=1233185478</a>, 2024.</div>
</div>
<div id="ref-Toth2020Hamiltonian" class="csl-entry" role="listitem">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">P. Toth, D. J. Rezende, A. Jaegle, S. Racanière, A. Botev, and I. Higgins, <span>“Hamiltonian generative networks,”</span> in <em>International <span>C</span>onference on <span>L</span>earning <span>R</span>epresentations <span>(ICLR)</span></em>, 2020. Available: <a href="https://openreview.net/forum?id=HJenn6VFvB">https://openreview.net/forum?id=HJenn6VFvB</a></div>
</div>
<div id="ref-hamiltonian_flows" class="csl-entry" role="listitem">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">P. Holderrieth, Y. Xu, and T. Jaakkola, <span>“Hamiltonian score matching and generative flows.”</span> 2024. Available: <a href="https://arxiv.org/abs/2410.20470">https://arxiv.org/abs/2410.20470</a></div>
</div>
</div>
<hr>
<ol start="3" type="a">
<li>2024 Scott H. Hawley</li>
</ol>
<section id="acknowledgement" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="acknowledgement">Acknowledgement</h4>
<p>This work was graciously supported by Belmont University, Hyperstate Music AI, Razer Inc., and NVIDIA’s Inception program. Much of this tutorial was hashed out through “conversations” with Claude 3.5 Sonnet.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>A related example from science fiction: in the fictitous “psychohistory” theory of Isaac Asimov’s <em>Foundation</em> series, the choices and “trajectories” of individual people can’t be predicted, but the aggregated development of an entire society follows predictable paths.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Note: my <span class="math inline">\(f(t)\)</span> is a close approximation to the “mode function” Eq. 20 in <span class="citation" data-cites="flux_paper"><a href="#ref-flux_paper" role="doc-biblioref">[1]</a></span>, with their <span class="math inline">\(s\)</span> being about (1.75 - <span class="math inline">\(s_{\rm mine}\)</span>), and with <span class="math inline">\(t\rightarrow 1-t\)</span>. My blue line is right underneath their purple line in the Desmos graph below – I didn’t plan that, just similar minds at work! Both our curves can do the Karras et al cosine schedule, shown in green in the the Desmos figure.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Check out <a href="https://yilun-xu.com/">Yilun Xu’s</a> work for more on physics-inspired generative models.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp("https:\/\/drscotthawley\.github\.io\/blog");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->



</body></html>