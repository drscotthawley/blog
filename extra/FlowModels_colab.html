<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>blog - Flow With What You Know (Colab Version)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
details > summary {
    color: #00966f;   /* the greenish tinge that appears in my blog */
    cursor: pointer; /* lil triangle thingy */
}
</style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
<meta name="twitter:title" content="blog - Flow With What You Know (Colab Version)">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://i.imgur.com/4Nir9T6.gif">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/drscotthawley" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/drscotthawley" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Flow With What You Know (Colab Version)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<blockquote class="blockquote">
<p>Basic physics provides a “straight, fast” way to get up to speed with flow-based generative models</p>
</blockquote>
<p>Author: Scott H. Hawley, Nov 13, 2024</p>
<section id="abstract" class="level3">
<h3 class="anchored" data-anchor-id="abstract">Abstract</h3>
<p>In this tutorial post, we provide an accessible introduction to flow-matching and rectified flow models, which are increasingly on the forefront of generative AI applications. Typical descriptions of them are usually laden with extensive probability-math equations, which can form barriers to the dissemination and understanding of these models. Fortunately, before they were couched in probabilities, the mechanisms underlying these models were grounded in basic physics, which provides an alternative and highly-accessible (yet isomorphic) representation of the processes involved. Let’s flow.</p>
</section>
<section id="code-installs-imports" class="level2">
<h2 class="anchored" data-anchor-id="code-installs-imports">Code: Installs &amp; Imports</h2>
<p>In this executable version of the notebook, we’ll get our installs and imports out of the way.</p>
<p>Much of the code in this lesson is hidden (or collapsed) by default becuase you don’t actually need to read it to understand the lesson. (Most of the code is just for plotting figures anyway.) Stil you can always expand the collapsed sections to read as much detail as you want.</p>
<p>Note also that this tutorial does not require a GPU runtime; CPU-only is fine for the toy models we’ll be using.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># On Colab, no need to pip-install these because they're preinstalled</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#%pip install -Uqq torch numpy matplotlib tqdm</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> HTML, display, clear_output, Image</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">#from tqdm.auto import tqdm   # On Colab, the "auto" &amp; "notebook" versions don't work but the vanilla version does</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> tqdm</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: for the small toy problem used in this lesson, CPU &amp; GPU performance are about the same.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'mps'</span> <span class="cf">if</span> torch.backends.mps.is_available() <span class="cf">else</span> <span class="st">'cpu'</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"device ="</span>,device)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Flow-based generative AI models have been gaining significant traction as alternatives or improvements to traditional diffusion approaches in image and audio synthesis. These models excel at learning optimal trajectories for transforming probability distributions, offering a mathematically elegant framework for data generation. The approach has seen renewed momentum following Black Forest Labs’ success with their FLUX models [1], spurring fresh interest in the theoretical foundations laid by earlier work on Rectified Flows [2] in ICLR 2023. Improvements such as [3] have even reached the level of state-of-the-art generative models for one or two-step generation.</p>
<p>Intuitively, these models operate akin to the fluid processes that transform the shapes of clouds in the sky. While recent expositions [4] have attempted to make these concepts more accessible through probability theory, the underlying physical principles offer a more direct path to understanding. By returning to the basic physical picture of flows that inspired these generative models, we can build both intuition and deep understanding - insights that may even guide the development of new approaches.</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title . (gif embed)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>HTML(<span class="st">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;div class="tenor-gif-embed" data-postid="8811006" data-share-method="host" data-aspect-ratio="1.22692" data-width="400px"&gt;&lt;a href="https://tenor.com/view/its-black-its-white-michael-jackson-video-gif-8811006"&gt;Its Black Its White Michael Jackson Video GIF&lt;/a&gt;from &lt;a href="https://tenor.com/search/its+black+its+white-gifs"&gt;Its Black Its White GIFs&lt;/a&gt;&lt;/div&gt; &lt;script type="text/javascript" async src="https://tenor.com/embed.js"&gt;&lt;/script&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;br&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="st">Source: Face-morphing example from Michael Jackson's  "Black Or White" (1991). &lt;br&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="st">Technically not a flow-based generative model[4] but similar enough to use for an intro image. ;-)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="whats-a-flow" class="level2">
<h2 class="anchored" data-anchor-id="whats-a-flow">What’s a Flow?</h2>
<p>In the real world, things typically follow curved paths - like water flowing in a river, or crowds of people navigating around obstacles. Here’s map of wind provided from the WW2010 atmospheric science project at UIUC: at every point in space, the wind has a velocity vector, and the air moves along “streamlines” or “trajectories” parallel to the velocity vectors…</p>
<p><img src="https://i.imgur.com/4Nir9T6.gif" class="img-fluid" alt="Wind flow map image from the University of Illinois WW2010 Project, http://ww2010.atmos.uiuc.edu/(Gh)/guides/maps/upa/wndvct.rxml"><br> Wind flow map image from the <a href="http://ww2010.atmos.uiuc.edu/(Gh)/guides/maps/upa/wndvct.rxml">University of Illinois WW2010 Project</a></p>
<p>Notice that the streamlines never cross. If the streams were to cross… “it would be bad.” That would imply that the velocity at some point is undefined.</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title . (gif embed)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>HTML(<span class="st">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;div class="tenor-gif-embed" data-postid="14635781" data-share-method="host" data-aspect-ratio="2.40601" data-width="400px"&gt;&lt;a href="https://tenor.com/view/dont-cross-the-streams-ghostbusters-gif-14635781"&gt;Dont Cross The Streams Ghostbusters GIF&lt;/a&gt;from &lt;a href="https://tenor.com/search/dont+cross+the+streams-gifs"&gt;Dont Cross The Streams GIFs&lt;/a&gt;&lt;/div&gt; &lt;script type="text/javascript" async src="https://tenor.com/embed.js"&gt;&lt;/script&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>By the way, this non-crossing property is what allows these flows to be invertible (i.e., reversable), a property you sometimes hear in isolation when reading more formal descriptions of flow models.</p>
<p>So at every point in space there’s a velocity vector telling the little bits of water where to go. And just like water or wind flows may depend not only on spatial position but also time, so too can our velocity vector field depend on position and time.</p>
<p>Flow matching learns these natural paths by focusing on the <em>velocity</em> at each point - essentially asking “which way should each point be moving at this moment?”</p>
<blockquote class="blockquote">
<p><strong>Terminology: “FM/RF”</strong></p>
<p>It may seem confusing to sometimes see “flow matching” and “rectified flows” being used interchangeably, but this is because they are <em>the same</em> [6]. In this blog we’ll use the collective term “FM/RF” models. Note that there is no explicit “rectification” mechanism in rectified flows; rather any “rectification” is a description of the effect of flow-matching, i.e.&nbsp;transformingn crossing trajectories to non-crossing ones. The addition of “Reflow” to the rectified flow paper <span class="citation" data-cites="rectified_flow">[@rectified_flow]</span> is a powerful extension we will cover further below.</p>
</blockquote>
</section>
</section>
<section id="how-do-fmrf-models-work" class="level1">
<h1>How Do FM/RF Models Work?</h1>
<p>To gain a deep understanding of how models work, having an executable toy model is often a key instructional tool. This tutorial is written as a executable Jupyter notebook, though you can make sense of it without the code, so we will typically collapse or hide the code. But if you want to see it, you can expand the drop-down arrows.</p>
<p>For instance, the code starts with importing packages…</p>
<p><strong>Choose Your Own Data Shapes</strong></p>
<p>The executable verison lets you choose various shapes to “morph” between. For this reading, we’ll go from a Gaussian to a Spiral:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Options are: 'Gaussian', 'Square', 'Heart', 'Spiral','Two Gaussians', 'Smiley'</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>source_data_choice <span class="op">=</span> <span class="st">'Gaussian'</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>target_data_choice <span class="op">=</span> <span class="st">'Spiral'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With the imports in place and the choice of starting and ending distributions chosen, we’re ready to define some of utilities to generate and visualize our data. Let’s take a look:</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Utility code: styles, functions, generators, visualization</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># for accessibility: Wong's color pallette: cf. https://davidmathlogic.com/colorblind</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#wong_black = [0/255, 0/255, 0/255]          # #000000</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>wong_amber <span class="op">=</span> [<span class="dv">230</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">159</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">0</span><span class="op">/</span><span class="dv">255</span>]      <span class="co"># #E69F00</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>wong_cyan <span class="op">=</span> [<span class="dv">86</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">180</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">233</span><span class="op">/</span><span class="dv">255</span>]      <span class="co"># #56B4E9</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>wong_green <span class="op">=</span> [<span class="dv">0</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">158</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">115</span><span class="op">/</span><span class="dv">255</span>]      <span class="co"># #009E73</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>wong_yellow <span class="op">=</span> [<span class="dv">240</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">228</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">66</span><span class="op">/</span><span class="dv">255</span>]    <span class="co"># #F0E442</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>wong_navy <span class="op">=</span> [<span class="dv">0</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">114</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">178</span><span class="op">/</span><span class="dv">255</span>]       <span class="co"># #0072B2</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>wong_red <span class="op">=</span> [<span class="dv">213</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">94</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">0</span><span class="op">/</span><span class="dv">255</span>]         <span class="co"># #D55E00</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>wong_pink <span class="op">=</span> [<span class="dv">204</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">121</span><span class="op">/</span><span class="dv">255</span>, <span class="dv">167</span><span class="op">/</span><span class="dv">255</span>]     <span class="co"># #CC79A7</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>wong_cmap <span class="op">=</span> [wong_amber, wong_cyan, wong_green, wong_yellow, wong_navy, wong_red, wong_pink]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>source_color <span class="op">=</span> wong_navy</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>target_color <span class="op">=</span> wong_red</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>pred_color <span class="op">=</span> wong_green</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>line_color <span class="op">=</span> wong_yellow</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>bg_theme <span class="op">=</span> <span class="st">'dark'</span> <span class="co">#  'black', 'white', 'dark', 'light'</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> bg_theme <span class="kw">in</span> [<span class="st">'black'</span>,<span class="st">'dark'</span>]:</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    plt.style.use(<span class="st">'dark_background'</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    plt.rcdefaults()</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co"># A few different data distributions</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_gaussian_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a 2D Gaussian distribution"""</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.randn(n_points, <span class="dv">2</span>) <span class="op">*</span> scale</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_square_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">3.0</span>):  <span class="co"># 3 is set by the spread of the gaussian and spiral</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create points uniformly distributed in a square"""</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate uniform points in a square</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> (torch.rand(n_points, <span class="dv">2</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> scale</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> points</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_spiral_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a spiral distribution. i like this one more"""</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    noise <span class="op">=</span> <span class="fl">0.1</span><span class="op">*</span>scale</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">#theta = torch.linspace(0, 6*np.pi, n_points) # preferred order? no way</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> <span class="dv">6</span><span class="op">*</span>np.pi<span class="op">*</span> torch.rand(n_points)</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> theta <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>np.pi) <span class="op">*</span> scale</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> r <span class="op">*</span> torch.cos(theta) <span class="op">+</span> noise <span class="op">*</span> torch.randn(n_points)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> r <span class="op">*</span> torch.sin(theta) <span class="op">+</span> noise <span class="op">*</span> torch.randn(n_points)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack([x, y], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_heart_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">3.0</span>):</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a heart-shaped distribution of points"""</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    square_points <span class="op">=</span> create_square_data(n_points, scale<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the heart-shaped condition for each point</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> square_points[:, <span class="dv">0</span>], square_points[:, <span class="dv">1</span>]</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    heart_condition <span class="op">=</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((<span class="dv">5</span> <span class="op">*</span> (y <span class="op">+</span> <span class="fl">0.25</span>) <span class="op">/</span> <span class="dv">4</span>) <span class="op">-</span> torch.sqrt(torch.<span class="bu">abs</span>(x)))<span class="op">**</span><span class="dv">2</span> <span class="op">&lt;=</span> <span class="dv">1</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter out points that don't satisfy the heart-shaped condition</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>    heart_points <span class="op">=</span> square_points[heart_condition]</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we don't have enough points, generate more</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(heart_points) <span class="op">&lt;</span> n_points:</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>        new_points <span class="op">=</span> create_square_data(n_points <span class="op">-</span> <span class="bu">len</span>(heart_points), scale<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> new_points[:, <span class="dv">0</span>], new_points[:, <span class="dv">1</span>]</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>        new_heart_condition <span class="op">=</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((<span class="dv">5</span> <span class="op">*</span> (y <span class="op">+</span> <span class="fl">0.25</span>) <span class="op">/</span> <span class="dv">4</span>) <span class="op">-</span> torch.sqrt(torch.<span class="bu">abs</span>(x)))<span class="op">**</span><span class="dv">2</span> <span class="op">&lt;=</span> <span class="dv">1</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>        new_heart_points <span class="op">=</span> new_points[new_heart_condition]</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>        heart_points <span class="op">=</span> torch.cat([heart_points, new_heart_points], dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>    heart_points <span class="op">*=</span> scale</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> heart_points[:n_points]</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_two_gaussians_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">1.0</span>, shift<span class="op">=</span><span class="fl">2.5</span>):</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create a 2D Gaussian distribution"""</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>    g  <span class="op">=</span> torch.randn(n_points, <span class="dv">2</span>) <span class="op">*</span> scale</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>    g[:n_points<span class="op">//</span><span class="dv">2</span>,<span class="dv">0</span>] <span class="op">-=</span> shift</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>    g[n_points<span class="op">//</span><span class="dv">2</span>:,<span class="dv">0</span>] <span class="op">+=</span> shift</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> torch.randperm(n_points)</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g[indices]</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_smiley_data(n_points<span class="op">=</span><span class="dv">1000</span>, scale<span class="op">=</span><span class="fl">2.5</span>):</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>    <span class="co">"make a smiley face"</span></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> []</span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Face circle</span></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">#angles = 2 * np.pi * torch.rand(n_points//2+20)</span></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">#r = scale + (scale/10)*torch.sqrt(torch.rand(n_points//2+20))</span></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">#points.append(torch.stack([r * torch.cos(angles), r * torch.sin(angles)], dim=1))</span></span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Eyes (small circles at fixed positions)</span></span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> eye_pos <span class="kw">in</span> [[<span class="op">-</span><span class="dv">1</span>, <span class="fl">0.9</span>], [<span class="dv">1</span>, <span class="fl">0.9</span>]]:</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>        eye <span class="op">=</span> torch.randn(n_points<span class="op">//</span><span class="dv">3</span><span class="op">+</span><span class="dv">20</span>, <span class="dv">2</span>) <span class="op">*</span> <span class="fl">0.2</span> <span class="op">+</span> torch.tensor(eye_pos) <span class="op">*</span> scale <span class="op">*</span> <span class="fl">0.4</span></span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>        points.append(eye)</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Smile (arc in polar coordinates)</span></span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> <span class="op">-</span>np.pi<span class="op">/</span><span class="dv">6</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.pi<span class="op">/</span><span class="dv">3</span><span class="op">*</span>torch.rand(n_points<span class="op">//</span><span class="dv">3</span><span class="op">+</span><span class="dv">20</span>)</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>    r_smile <span class="op">=</span> scale <span class="op">*</span> <span class="fl">0.6</span> <span class="op">+</span> (scale<span class="op">/</span><span class="dv">4</span>)<span class="op">*</span> torch.rand_like(theta)</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>    points.append(torch.stack([r_smile <span class="op">*</span> torch.cos(theta), r_smile <span class="op">*</span> torch.sin(theta)], dim<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> torch.cat(points, dim<span class="op">=</span><span class="dv">0</span>)  <span class="co"># concatenate first</span></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> points[torch.randperm(points.shape[<span class="dv">0</span>])]  <span class="co"># then shuffle</span></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> points[:n_points,:]</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize generator functions</span></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>source_gen_fn <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>target_gen_fn <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign generator functions based on user choices</span></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> gen_choice, gen_fn_name <span class="kw">in</span> <span class="bu">zip</span>([source_data_choice, target_data_choice], [<span class="st">'source_gen_fn'</span>, <span class="st">'target_gen_fn'</span>]):</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>    gen_choice <span class="op">=</span> gen_choice.lower()</span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'two gaussians'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_two_gaussians_data</span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'heart'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_heart_data</span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'spiral'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_spiral_data</span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'square'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_square_data</span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="st">'smiley'</span> <span class="kw">in</span> gen_choice:</span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_smiley_data</span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a>        gen_fn <span class="op">=</span> create_gaussian_data</span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-120"><a href="#cb7-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> gen_fn_name <span class="op">==</span> <span class="st">'source_gen_fn'</span>:</span>
<span id="cb7-121"><a href="#cb7-121" aria-hidden="true" tabindex="-1"></a>        source_gen_fn <span class="op">=</span> gen_fn</span>
<span id="cb7-122"><a href="#cb7-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb7-123"><a href="#cb7-123" aria-hidden="true" tabindex="-1"></a>        target_gen_fn <span class="op">=</span> gen_fn</span>
<span id="cb7-124"><a href="#cb7-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-125"><a href="#cb7-125" aria-hidden="true" tabindex="-1"></a><span class="co"># A couple aliases so we can easily switch distributions without affecting later code</span></span>
<span id="cb7-126"><a href="#cb7-126" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_source_data(n_points<span class="op">=</span><span class="dv">1000</span>, hshift<span class="op">=</span><span class="dv">0</span>):  <span class="co"># hshift can make it a bit easier to see trajectories later</span></span>
<span id="cb7-127"><a href="#cb7-127" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> source_gen_fn(n_points<span class="op">=</span>n_points)</span>
<span id="cb7-128"><a href="#cb7-128" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> hshift <span class="op">!=</span> <span class="dv">0</span>: g[:,<span class="dv">0</span>] <span class="op">+=</span> hshift</span>
<span id="cb7-129"><a href="#cb7-129" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g</span>
<span id="cb7-130"><a href="#cb7-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-131"><a href="#cb7-131" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_target_data(n_points<span class="op">=</span><span class="dv">1000</span>, hshift<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb7-132"><a href="#cb7-132" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> target_gen_fn(n_points<span class="op">=</span>n_points)</span>
<span id="cb7-133"><a href="#cb7-133" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> hshift <span class="op">!=</span> <span class="dv">0</span>: g[:,<span class="dv">0</span>] <span class="op">+=</span> hshift</span>
<span id="cb7-134"><a href="#cb7-134" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g</span>
<span id="cb7-135"><a href="#cb7-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-136"><a href="#cb7-136" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_distributions(dist1, dist2, title1<span class="op">=</span><span class="st">"Distribution 1"</span>, title2<span class="op">=</span><span class="st">"Distribution 2"</span>, alpha<span class="op">=</span><span class="fl">0.8</span>):</span>
<span id="cb7-137"><a href="#cb7-137" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Plot two distributions side by side"""</span></span>
<span id="cb7-138"><a href="#cb7-138" aria-hidden="true" tabindex="-1"></a>    plt.close(<span class="st">'all'</span>)</span>
<span id="cb7-139"><a href="#cb7-139" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb7-140"><a href="#cb7-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-141"><a href="#cb7-141" aria-hidden="true" tabindex="-1"></a>    ax1.scatter(dist1[:, <span class="dv">0</span>], dist1[:, <span class="dv">1</span>], alpha<span class="op">=</span>alpha, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>source_color)</span>
<span id="cb7-142"><a href="#cb7-142" aria-hidden="true" tabindex="-1"></a>    ax2.scatter(dist2[:, <span class="dv">0</span>], dist2[:, <span class="dv">1</span>], alpha<span class="op">=</span>alpha, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>target_color)</span>
<span id="cb7-143"><a href="#cb7-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-144"><a href="#cb7-144" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(title1)</span>
<span id="cb7-145"><a href="#cb7-145" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(title2)</span>
<span id="cb7-146"><a href="#cb7-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-147"><a href="#cb7-147" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set same scale for both plots</span></span>
<span id="cb7-148"><a href="#cb7-148" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb7-149"><a href="#cb7-149" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(dist1).<span class="bu">max</span>().item(),</span>
<span id="cb7-150"><a href="#cb7-150" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(dist2).<span class="bu">max</span>().item()</span>
<span id="cb7-151"><a href="#cb7-151" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-152"><a href="#cb7-152" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ax <span class="kw">in</span> [ax1, ax2]:</span>
<span id="cb7-153"><a href="#cb7-153" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb7-154"><a href="#cb7-154" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb7-155"><a href="#cb7-155" aria-hidden="true" tabindex="-1"></a>        ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb7-156"><a href="#cb7-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-157"><a href="#cb7-157" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb7-158"><a href="#cb7-158" aria-hidden="true" tabindex="-1"></a>    plt.show()  <span class="co"># Explicitly show the plot</span></span>
<span id="cb7-159"><a href="#cb7-159" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb7-160"><a href="#cb7-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-161"><a href="#cb7-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-162"><a href="#cb7-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-163"><a href="#cb7-163" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpolate_color(t, start<span class="op">=</span><span class="st">'blue'</span>, end<span class="op">=</span><span class="st">'red'</span>):</span>
<span id="cb7-164"><a href="#cb7-164" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Interpolate from matplotlib's default green (t=0) to red (t=1)"""</span></span>
<span id="cb7-165"><a href="#cb7-165" aria-hidden="true" tabindex="-1"></a>    start_color <span class="op">=</span> plt.cm.colors.to_rgb(start)</span>
<span id="cb7-166"><a href="#cb7-166" aria-hidden="true" tabindex="-1"></a>    end_color <span class="op">=</span> plt.cm.colors.to_rgb(end)</span>
<span id="cb7-167"><a href="#cb7-167" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">1</span><span class="op">-</span>t) <span class="op">*</span> np.array(start_color) <span class="op">+</span> t <span class="op">*</span> np.array(end_color)</span>
<span id="cb7-168"><a href="#cb7-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-169"><a href="#cb7-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-170"><a href="#cb7-170" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> show_flow_sequence(start_dist, end_dist, n_steps<span class="op">=</span><span class="dv">5</span>, c_start<span class="op">=</span>source_color, c_end<span class="op">=</span>target_color):</span>
<span id="cb7-171"><a href="#cb7-171" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Show the flow as a sequence of static plots"""</span></span>
<span id="cb7-172"><a href="#cb7-172" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_steps, figsize<span class="op">=</span>(<span class="dv">4</span><span class="op">*</span>n_steps, <span class="dv">4</span>))</span>
<span id="cb7-173"><a href="#cb7-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-174"><a href="#cb7-174" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb7-175"><a href="#cb7-175" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(start_dist).<span class="bu">max</span>().item(),</span>
<span id="cb7-176"><a href="#cb7-176" aria-hidden="true" tabindex="-1"></a>        <span class="bu">abs</span>(end_dist).<span class="bu">max</span>().item()</span>
<span id="cb7-177"><a href="#cb7-177" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-178"><a href="#cb7-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-179"><a href="#cb7-179" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axes):</span>
<span id="cb7-180"><a href="#cb7-180" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> i <span class="op">/</span> (n_steps <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-181"><a href="#cb7-181" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> start_dist <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>t) <span class="op">+</span> end_dist <span class="op">*</span> t</span>
<span id="cb7-182"><a href="#cb7-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-183"><a href="#cb7-183" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> interpolate_color(t, start<span class="op">=</span>c_start, end<span class="op">=</span>c_end)</span>
<span id="cb7-184"><a href="#cb7-184" aria-hidden="true" tabindex="-1"></a>        ax.scatter(current[:, <span class="dv">0</span>], current[:, <span class="dv">1</span>],</span>
<span id="cb7-185"><a href="#cb7-185" aria-hidden="true" tabindex="-1"></a>                  alpha<span class="op">=</span><span class="fl">0.8</span>, s<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb7-186"><a href="#cb7-186" aria-hidden="true" tabindex="-1"></a>                  c<span class="op">=</span>[color])</span>
<span id="cb7-187"><a href="#cb7-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-188"><a href="#cb7-188" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb7-189"><a href="#cb7-189" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb7-190"><a href="#cb7-190" aria-hidden="true" tabindex="-1"></a>        ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb7-191"><a href="#cb7-191" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f't = </span><span class="sc">{</span>t<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb7-192"><a href="#cb7-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-193"><a href="#cb7-193" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb7-194"><a href="#cb7-194" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb7-195"><a href="#cb7-195" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb7-196"><a href="#cb7-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-197"><a href="#cb7-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-198"><a href="#cb7-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-199"><a href="#cb7-199" aria-hidden="true" tabindex="-1"></a><span class="co"># Create our distributions and look at them</span></span>
<span id="cb7-200"><a href="#cb7-200" aria-hidden="true" tabindex="-1"></a>n_points <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb7-201"><a href="#cb7-201" aria-hidden="true" tabindex="-1"></a>source, target <span class="op">=</span> create_source_data(n_points), create_target_data(n_points)</span>
<span id="cb7-202"><a href="#cb7-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-203"><a href="#cb7-203" aria-hidden="true" tabindex="-1"></a>plot_distributions(source, target, <span class="st">"Starting Distribution"</span>, <span class="st">"Target Distribution"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The process of transition from the starting “source” to the final “target” might include snapshots like these:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>show_flow_sequence(source, target, n_steps<span class="op">=</span><span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>(Note the colors aren’t meaningful, they’re just added to make it easier to distinguish what we’re looking at. Our data are just points in 2-D space.)</p>
<!---Here's an animation with no colors, showing the points moving. ... --->
<p>So, how do we get the points from the source distribution to fit with the target distribution? The simplest way (though not the only way) is to assume points move in straight lines from source to target. Even though our network might learn more complex paths later, this gives us a starting point for training.</p>
<section id="the-starting-setup" class="level2">
<h2 class="anchored" data-anchor-id="the-starting-setup">The Starting Setup</h2>
<p>The training setup for flow matching models is as follows: 1. We start by <em>randomly pairing</em> points from the source &amp; the target – yes, really. :rofl: 2. We move the points along straight trajectories, and the speed of each point is constant.</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code for 2D flow-matching diagram with crossing lines</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>source_L <span class="op">=</span> source.clone()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>shift <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>source_L[:,<span class="dv">0</span>] <span class="op">-=</span> shift</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>target_R <span class="op">=</span> target.clone()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>target_R[:,<span class="dv">0</span>] <span class="op">+=</span> shift  <span class="co"># Note: fixed the indexing here from [:0] to [:,0]</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># show the whole distribution</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>ax.scatter(source_L[:,<span class="dv">0</span>], source_L[:,<span class="dv">1</span>], color<span class="op">=</span>source_color, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>ax.scatter(target_R[:,<span class="dv">0</span>], target_R[:,<span class="dv">1</span>], color<span class="op">=</span>target_color, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw lines connecting points, with source &amp; target points outlined</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>n_lines <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>ax.scatter(source_L[:n_lines,<span class="dv">0</span>], source_L[:n_lines,<span class="dv">1</span>], color<span class="op">=</span>source_color, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>           facecolor<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span>line_color,)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>ax.scatter(target_R[:n_lines,<span class="dv">0</span>], target_R[:n_lines,<span class="dv">1</span>], color<span class="op">=</span>target_color, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>           facecolor<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span>line_color,)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_lines):</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    ax.plot([source_L[i,<span class="dv">0</span>], target_R[i,<span class="dv">0</span>]],</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        [source_L[i,<span class="dv">1</span>], target_R[i,<span class="dv">1</span>]],</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span>line_color<span class="op">+</span>[<span class="fl">.9</span>],</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        linewidth<span class="op">=</span><span class="dv">2</span>)  <span class="co"># or lw=2</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'top'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'right'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'bottom'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">'left'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> [x, label] <span class="kw">in</span> <span class="bu">zip</span>([<span class="op">-</span>shift,shift], [<span class="st">'Source'</span>,<span class="st">'Target'</span>]):</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    ax.text(x, <span class="dv">4</span>, label, fontsize<span class="op">=</span><span class="dv">12</span>, color<span class="op">=</span><span class="st">'black'</span>, ha<span class="op">=</span><span class="st">'center'</span>,  va<span class="op">=</span><span class="st">'center'</span>,)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>os.makedirs(<span class="st">'images'</span>, exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>save_file<span class="op">=</span><span class="st">'images/gaussian_to_spiral_crossing_lines.png'</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>plt.savefig(save_file)</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are big issues with doing this: The random pairing results in lots of trajectories that cross each other. But this is a <em>starting point</em> for Flow Matching. So in other words, when training a Flow Matching model…</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title . (gif embed)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>HTML(<span class="st">"""</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExNm4yN3J1MXhlYWVnNGJ5MWk5enF0bDdxcmhuaHc4b3Awbmh6ZDRqayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3o72EWUgbRNfLegO1W/giphy.gif"&gt;"</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>…well, ok not quite: we’re going to allow the <em>trajectories of individual points</em> to cross as we train the model. This <em>is</em> a bit “confusing” for the model, which will be trying to learn a velocity field, and that isn’t defined where trajectories cross. Eventually, however, the model will learn to estimate the <em>aggregated motion</em> of many particles, which will sort of average out to arrive at the “bulk motion” of the flow. This is similar to how the brownian motion of many air or water particles averages out on the macroscopic level, giving us streamlines that don’t cross.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>This is why flow matching is about transforming <em>distributions</em>, not individual points. The learned velocity field might not exactly match any of our training trajectories, but it captures the statistical flow needed to transform one distribution into another.</p>
<p>Here’s a visualization from the code we’ll execute later in the lesson. We’ll plot…</p>
<ol type="1">
<li>Our naive training trajectories (with crossings)</li>
<li>The actual learned flow field</li>
<li>The paths points take when following the learned field</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://i.imgur.com/ZXIRlE1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">cross-uncross-plot</figcaption>
</figure>
</div>
<p><img src="images/cross_uncross_plot.png" class="img-fluid"> Left: Training data uses simple straight lines (with many crossings). Middle: The learned flow (velocity vector) field is smooth and continuous. Right: Actual trajectories following the flow field don’t cross.</p>
</section>
<section id="how-are-flows-learned" class="level2">
<h2 class="anchored" data-anchor-id="how-are-flows-learned">How Are Flows ‘Learned’?</h2>
<p>The goal of the macahine learning system is as follows: for any point in space and any time t between 0 and 1, we want to learn the correct <em>velocity</em> (direction and speed) that point should move. It’s like learning the “wind map” that will blow the starting distribution cloud into the shape of the target distribution cloud.</p>
<p>Since neural networks are such useful engines for approximation and interpolation, we’ll let a neural network “learn” to estimate the mapping between locations and times (as inputs), and velocities (as outputs).</p>
<blockquote class="blockquote">
<p><strong>Terminology: “Simulation Free”</strong></p>
<p>You’ll sometimes see flow-maching models being referred to as “simulation free.” This just an indication that the flow we arrive is not the result of any explicit simulation of any process (physical or otherwise). The flow obtained arises simply from the aggregation of many particles moving along imagined straight lines and crossing paths.</p>
</blockquote>
<section id="the-neural-networks-job" class="level3">
<h3 class="anchored" data-anchor-id="the-neural-networks-job">The Neural Network’s Job</h3>
<p>The neural network has one job: given a position in space and a time, to output a velocity vector. <em>That’s all it does.</em> Below is the code for this model that will “learn” to estimate velocity vectors.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VelocityNet(nn.Module):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_dim, h_dim<span class="op">=</span><span class="dv">64</span>):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc_in  <span class="op">=</span> nn.Linear(input_dim <span class="op">+</span> <span class="dv">1</span>, h_dim)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc2    <span class="op">=</span> nn.Linear(h_dim, h_dim)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc3    <span class="op">=</span> nn.Linear(h_dim, h_dim)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc_out <span class="op">=</span> nn.Linear(h_dim, input_dim)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x, t, act<span class="op">=</span>F.gelu):</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> t.expand(x.size(<span class="dv">0</span>), <span class="dv">1</span>)  <span class="co"># Ensure t has the correct dimensions</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.cat([x, t], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> act(<span class="va">self</span>.fc_in(x))</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> act(<span class="va">self</span>.fc2(x))</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> act(<span class="va">self</span>.fc3(x))</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.fc_out(x)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Instantiate the model</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>input_dim <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> VelocityNet(input_dim)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>model.to(device)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>…That’s it! Looks pretty simple, right? That’s because to make the system work we’ll need more than just the velocity field model.</p>
<p>Apart from the velocity model (i.e., the neural network, for us), the rest of the software system then uses these generated velocities to move points around. The model’s velocities are then used in a differential equation describing the small change each particle’s position <span class="math inline">\(\vec{r}\)</span> over a short time:</p>
<p><span class="math display">\[ d\vec{r} = v(\vec{r},t) dt\]</span></p>
<p>The is integrated by some (totally separate) numerical integration routine. A popular choice in the machine learning world is the “forward Euler” method, which is simple to implement, but will need to be upgraded (see furter below) to get good results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fwd_euler_step(model, current_points, current_t, dt):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    velocity <span class="op">=</span> model(current_points, current_t)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_points <span class="op">+</span> velocity <span class="op">*</span> dt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Integrator code: generate/predict samples using the trained model</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integrate_path(model, initial_points, step_fn<span class="op">=</span>fwd_euler_step, n_steps<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                   save_trajectories<span class="op">=</span><span class="va">False</span>, warp_fn<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""this 'sampling' routine is primarily used for visualization."""</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    current_points <span class="op">=</span> initial_points.clone()</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    ts <span class="op">=</span>  torch.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n_steps).to(device)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> warp_fn: ts <span class="op">=</span> warp_fn(ts)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_trajectories: trajectories <span class="op">=</span> [current_points]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ts)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        current_points <span class="op">=</span> step_fn(model, current_points, ts[i], ts[i<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>ts[i])</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> save_trajectories: trajectories.append(current_points)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_trajectories: <span class="cf">return</span> current_points, torch.stack(trajectories).cpu()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current_points</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>generate_samples <span class="op">=</span> integrate_path <span class="co"># just lil' alias for the probability / diffusion model crowd ;-)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="training-code" class="level2">
<h2 class="anchored" data-anchor-id="training-code">Training Code</h2>
<p>The goal of the training code is twofold: 1. to expose the model as many locations and times as possible – at least for those times &amp; locations that “matter most”. This exposure is what I’ll refer to as “coverage”. 2. to force it to learn to generate (approximately) correct velocities at those times and locations.</p>
<p>That’s it. The training code doesn’t actually do any integration or solving, but we’ll typically execute the integration just to visualize “how we’re doing” as the training progresses.</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Viz code: calls integrator to calc motion given v field, makes pictures</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Viz code: calls integrator to calc motion given v field, makes pictures"</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> viz(val_points, target_samples, trained_model, size<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, n_steps<span class="op">=</span><span class="dv">100</span>, warp_fn<span class="op">=</span><span class="va">None</span>,):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate and visualize new samples</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(trained_model.parameters()).device</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    generated_samples, trajectories <span class="op">=</span> integrate_path(trained_model, val_points.to(device), n_steps<span class="op">=</span>n_steps, warp_fn<span class="op">=</span>warp_fn, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    n_viz <span class="op">=</span> <span class="bu">min</span>(<span class="dv">30</span>, <span class="bu">len</span>(trajectories[<span class="dv">0</span>]))  <span class="co"># Number of trajectories to visualize</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">13</span>,<span class="dv">3</span>))</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    data_list <span class="op">=</span> [val_points.cpu(), generated_samples.cpu(), target_samples.cpu()]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    label_list <span class="op">=</span> [<span class="st">'Initial Points'</span>, <span class="st">'Generated Samples'</span>, <span class="st">'Target Data'</span>,<span class="st">'Trajectories'</span>]</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    color_list <span class="op">=</span> [source_color, pred_color, target_color]</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    global_max <span class="op">=</span> <span class="bu">max</span>( torch.<span class="bu">max</span>(torch.<span class="bu">abs</span>(torch.cat(data_list)),<span class="dv">0</span>)[<span class="dv">0</span>][<span class="dv">0</span>],  torch.<span class="bu">max</span>(torch.<span class="bu">abs</span>(torch.cat(data_list)),<span class="dv">0</span>)[<span class="dv">0</span>][<span class="dv">1</span>] )</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(label_list)):</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>        ax[i].set_title(label_list[i])</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        ax[i].set_xlim([<span class="op">-</span>global_max, global_max])</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        ax[i].set_ylim([<span class="op">-</span>global_max, global_max])</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">3</span>: <span class="co"># non-trajectory plots</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>            ax[i].scatter( data_list[i][:, <span class="dv">0</span>], data_list[i][:, <span class="dv">1</span>], s<span class="op">=</span>size, alpha<span class="op">=</span>alpha,</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>                          label<span class="op">=</span>label_list[i], color<span class="op">=</span>color_list[i])</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Plot trajectory paths first</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_viz):</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>                path <span class="op">=</span> trajectories[:, j]</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>                ax[<span class="dv">3</span>].plot(path[:, <span class="dv">0</span>], path[:, <span class="dv">1</span>], <span class="st">'-'</span>, color<span class="op">=</span>line_color, alpha<span class="op">=</span><span class="dv">1</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Then plot start and end points for the SAME trajectories</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>            start_points <span class="op">=</span> trajectories[<span class="dv">0</span>, :n_viz]</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>            end_points <span class="op">=</span> trajectories[<span class="op">-</span><span class="dv">1</span>, :n_viz]</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">3</span>].scatter(start_points[:, <span class="dv">0</span>], start_points[:, <span class="dv">1</span>], color<span class="op">=</span>source_color, s<span class="op">=</span>size, alpha<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Source Points'</span>)</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">3</span>].scatter(end_points[:, <span class="dv">0</span>], end_points[:, <span class="dv">1</span>], color<span class="op">=</span>pred_color, s<span class="op">=</span>size, alpha<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Current Endpoints'</span>)</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">3</span>].legend()</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the data</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>source_samples <span class="op">=</span> create_source_data(n_samples)</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>target_samples <span class="op">=</span> create_target_data(n_samples)</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>val_points <span class="op">=</span> create_source_data(n_samples)</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Testing visualization routines (before training):"</span>)</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>viz(val_points, target_samples,  model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The clever part about flow matching is how we train this network. For each training step:</p>
<ol type="1">
<li>Sample random points from our source distribution</li>
<li>Sample random time points between 0 and 1</li>
<li>Calculate where these points <em>should</em> be at those times (we’ll see how in a moment)</li>
<li>Calculate what velocity they <em>should</em> have at those times</li>
<li>Train the network to predict these velocities</li>
</ol>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code for train_model() training loop</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code for train_model() training loop"</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.optim <span class="im">as</span> optim</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_model(model, n_epochs<span class="op">=</span><span class="dv">100</span>, lr<span class="op">=</span><span class="fl">0.003</span>, batch_size<span class="op">=</span><span class="dv">2048</span>, status_every<span class="op">=</span><span class="dv">1</span>, viz_every<span class="op">=</span><span class="dv">1</span>, warp_fn<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span>lr)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    loss_fn <span class="op">=</span> nn.MSELoss()</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    step, n_steps <span class="op">=</span> <span class="dv">0</span>, <span class="dv">100</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        model.train()</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        pbar <span class="op">=</span> tqdm(<span class="bu">range</span>(n_steps), leave<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> pbar:</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            step <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># by randomly generating new data each step, we prevent the model from merely memorizing</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>            source_samples <span class="op">=</span> create_source_data(batch_size).to(device)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            target_samples <span class="op">=</span> create_target_data(batch_size).to(device)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> torch.rand(source_samples.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device)  <span class="co"># random times for traning</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> warp_fn: t <span class="op">=</span> warp_fn(t)    <span class="co"># time warp is good for coverage but not as helpful for training as it is during integration/sampling</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>            interpolated_samples <span class="op">=</span> source_samples <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> t) <span class="op">+</span> target_samples <span class="op">*</span> t</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>            line_directions <span class="op">=</span> target_samples <span class="op">-</span> source_samples</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>            drift <span class="op">=</span> model(interpolated_samples, t)</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> loss_fn(drift, line_directions)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>            loss.backward()</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>            status_str <span class="op">=</span> <span class="ss">f'Epoch [</span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>n_epochs<span class="sc">}</span><span class="ss">], Loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">:.4f}</span><span class="ss">'</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>            pbar.set_description(status_str) <span class="co"># colab not showing any progress bar???</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (epoch <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> viz_every <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>            model.<span class="bu">eval</span>()</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>            clear_output(wait<span class="op">=</span><span class="va">True</span>)  <span class="co"># Clear previous plots</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>            viz(val_points, target_samples[:val_points.shape[<span class="dv">0</span>]], model)</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>            plt.show()</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>            plt.close()  <span class="co"># Close the figure to free memory</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>            model.train()</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> epoch<span class="op">==</span>n_epochs<span class="op">-</span><span class="dv">1</span>: <span class="bu">print</span>(status_str)  <span class="co"># keep last status from being cleared</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>fm_model <span class="op">=</span> train_model(model, n_epochs<span class="op">=</span><span class="dv">100</span>)     <span class="co"># Run traiing; this will take a couple minutes</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s an animation of our model integrating the flow from start to finish:</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code for animating points in flow</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code for animating points in flow"</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.animation <span class="im">as</span> animation</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> HTML, display, clear_output</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> rc</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_flow_animation(start_dist, models, titles<span class="op">=</span><span class="va">None</span>, figsize<span class="op">=</span><span class="va">None</span>, n_frames<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>                         step_fn<span class="op">=</span>fwd_euler_step, n_steps<span class="op">=</span><span class="dv">100</span>, warp_fn<span class="op">=</span><span class="va">None</span>, save_file<span class="op">=</span><span class="va">None</span>, height<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Create an animation showing multiple distribution flows</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co">        start_dist: Starting distribution</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">        models: List of models to animate</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co">        titles: List of titles for each subplot (optional)</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="co">        figsize: Figure size (optional)</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="co">        n_frames: Number of animation frames</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="co">        integrator: Integration function to use</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="co">        jitter: Amount of jitter to add</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="co">        save_file: Path to save animation (optional)</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="co">        height: Height of each subplot</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    plt.close(<span class="st">'all'</span>)  <span class="co"># Close all open figures</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(models, <span class="bu">list</span>): models <span class="op">=</span> [models]</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    n_plots <span class="op">=</span> <span class="bu">len</span>(models)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> titles <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>        titles <span class="op">=</span> [<span class="ss">f'Flow </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_plots)]</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">len</span>(titles) <span class="op">!=</span> n_plots:</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Number of titles (</span><span class="sc">{</span><span class="bu">len</span>(titles)<span class="sc">}</span><span class="ss">) must match number of models (</span><span class="sc">{</span>n_plots<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate figure size</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> figsize <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>        figsize <span class="op">=</span> [height <span class="op">*</span> n_plots, height]</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create subplots</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_plots, figsize<span class="op">=</span>figsize)</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_plots <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>        axes <span class="op">=</span> [axes]</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>    plt.close()  <span class="co"># Close the figure immediately</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize scatters and trajectories</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>    scatters <span class="op">=</span> []</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>    all_trajectories <span class="op">=</span> []</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate trajectories for each model</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">abs</span>(start_dist).<span class="bu">max</span>().item()</span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, model <span class="kw">in</span> <span class="bu">enumerate</span>(models):</span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>        device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>        end_dist, trajectories <span class="op">=</span> integrate_path(model, start_dist.clone().to(device), n_steps<span class="op">=</span>n_frames,</span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a>                                          step_fn<span class="op">=</span>step_fn, warp_fn<span class="op">=</span>warp_fn, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a>        all_trajectories.append(trajectories.cpu())</span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a>        scatters.append(axes[i].scatter([], [], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>wong_pink))</span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update max range</span></span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a>        max_range <span class="op">=</span> <span class="bu">max</span>(max_range, <span class="bu">abs</span>(end_dist.cpu()).<span class="bu">max</span>().item())</span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up axes</span></span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axes):</span>
<span id="cb17-66"><a href="#cb17-66" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb17-67"><a href="#cb17-67" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb17-68"><a href="#cb17-68" aria-hidden="true" tabindex="-1"></a>        ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb17-69"><a href="#cb17-69" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb17-70"><a href="#cb17-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> spine <span class="kw">in</span> [<span class="st">'top'</span>, <span class="st">'right'</span>, <span class="st">'bottom'</span>, <span class="st">'left'</span>]:</span>
<span id="cb17-71"><a href="#cb17-71" aria-hidden="true" tabindex="-1"></a>            ax.spines[spine].set_visible(<span class="va">False</span>)</span>
<span id="cb17-72"><a href="#cb17-72" aria-hidden="true" tabindex="-1"></a>        ax.set_title(titles[i])</span>
<span id="cb17-73"><a href="#cb17-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-74"><a href="#cb17-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> init():</span>
<span id="cb17-75"><a href="#cb17-75" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Initialize animation"""</span></span>
<span id="cb17-76"><a href="#cb17-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> scatter <span class="kw">in</span> scatters:</span>
<span id="cb17-77"><a href="#cb17-77" aria-hidden="true" tabindex="-1"></a>            scatter.set_offsets(np.c_[[], []])</span>
<span id="cb17-78"><a href="#cb17-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">tuple</span>(scatters)</span>
<span id="cb17-79"><a href="#cb17-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-80"><a href="#cb17-80" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> animate(frame):</span>
<span id="cb17-81"><a href="#cb17-81" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Update animation frame"""</span></span>
<span id="cb17-82"><a href="#cb17-82" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update axis limits (in case they need to be adjusted)</span></span>
<span id="cb17-83"><a href="#cb17-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ax <span class="kw">in</span> axes:</span>
<span id="cb17-84"><a href="#cb17-84" aria-hidden="true" tabindex="-1"></a>            ax.set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb17-85"><a href="#cb17-85" aria-hidden="true" tabindex="-1"></a>            ax.set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb17-86"><a href="#cb17-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-87"><a href="#cb17-87" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update scatter positions</span></span>
<span id="cb17-88"><a href="#cb17-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> scatter, trajectories <span class="kw">in</span> <span class="bu">zip</span>(scatters, all_trajectories):</span>
<span id="cb17-89"><a href="#cb17-89" aria-hidden="true" tabindex="-1"></a>            scatter.set_offsets(trajectories[frame].numpy())</span>
<span id="cb17-90"><a href="#cb17-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-91"><a href="#cb17-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">tuple</span>(scatters)</span>
<span id="cb17-92"><a href="#cb17-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-93"><a href="#cb17-93" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create animation</span></span>
<span id="cb17-94"><a href="#cb17-94" aria-hidden="true" tabindex="-1"></a>    anim <span class="op">=</span> animation.FuncAnimation(fig, animate, init_func<span class="op">=</span>init,</span>
<span id="cb17-95"><a href="#cb17-95" aria-hidden="true" tabindex="-1"></a>                                 frames<span class="op">=</span>n_frames, interval<span class="op">=</span><span class="dv">20</span>, blit<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-96"><a href="#cb17-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-97"><a href="#cb17-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle saving or displaying</span></span>
<span id="cb17-98"><a href="#cb17-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_file:</span>
<span id="cb17-99"><a href="#cb17-99" aria-hidden="true" tabindex="-1"></a>        os.makedirs(os.path.dirname(save_file), exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-100"><a href="#cb17-100" aria-hidden="true" tabindex="-1"></a>        anim.save(save_file, writer<span class="op">=</span><span class="st">'ffmpeg'</span>, fps<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb17-101"><a href="#cb17-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(<span class="ss">f"""&lt;center&gt;&lt;video height="350" controls loop&gt;&lt;source src="</span><span class="sc">{</span>anim_file<span class="sc">}</span><span class="ss">" type="video/mp4"&gt;</span></span>
<span id="cb17-102"><a href="#cb17-102" aria-hidden="true" tabindex="-1"></a><span class="ss">              Your browser does not support the video tag. &lt;/video&gt;&lt;/center&gt;"""</span>)</span>
<span id="cb17-103"><a href="#cb17-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:  <span class="co"># direct matplotlib anim offers better controls but makes ipynb file size huge</span></span>
<span id="cb17-104"><a href="#cb17-104" aria-hidden="true" tabindex="-1"></a>        rc(<span class="st">'animation'</span>, html<span class="op">=</span><span class="st">'jshtml'</span>)</span>
<span id="cb17-105"><a href="#cb17-105" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(anim.to_jshtml())</span>
<span id="cb17-106"><a href="#cb17-106" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb17-107"><a href="#cb17-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-108"><a href="#cb17-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-109"><a href="#cb17-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-110"><a href="#cb17-110" aria-hidden="true" tabindex="-1"></a><span class="co">#anim_file = 'images/particles_fm.mp4'</span></span>
<span id="cb17-111"><a href="#cb17-111" aria-hidden="true" tabindex="-1"></a>create_flow_animation(val_points.clone(), models<span class="op">=</span>[fm_model], titles<span class="op">=</span>[<span class="st">'Flow Matching'</span>],</span>
<span id="cb17-112"><a href="#cb17-112" aria-hidden="true" tabindex="-1"></a>                      n_frames<span class="op">=</span><span class="dv">50</span>, save_file<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So, even though we trained using trajectories that crossed, what the model learned were non-crossing (but curvy!) trajectories. Here’s a static plot of these:</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code to plot initial crossing trajectories vs. learned flow</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_training_trajectories_vs_learned_flow(model):</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>   <span class="co">"""Compare training trajectories with learned flow field"""</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>   plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>   <span class="co"># 1. Plot some training trajectories</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>   plt.subplot(<span class="dv">131</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>   n_trajs <span class="op">=</span> <span class="dv">50</span>  <span class="co"># Number of trajectories to show</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>   device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>   source <span class="op">=</span> create_gaussian_data(n_trajs)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>   target <span class="op">=</span> create_square_data(n_trajs)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>   current_points <span class="op">=</span> source.clone().to(device)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Plot straight-line trajectories from source to target</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>   times <span class="op">=</span> torch.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">20</span>)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_trajs):</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>       traj <span class="op">=</span> source[i:i<span class="op">+</span><span class="dv">1</span>] <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> times.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">+</span> target[i:i<span class="op">+</span><span class="dv">1</span>] <span class="op">*</span> times.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>       plt.plot(traj[:, <span class="dv">0</span>], traj[:, <span class="dv">1</span>], <span class="st">'b-'</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>   plt.title(<span class="st">'Training Trajectories</span><span class="ch">\n</span><span class="st">(with crossings)'</span>)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>   plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>   <span class="co"># 2. Plot learned flow field</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>   plt.subplot(<span class="dv">132</span>)</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>   x <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>   y <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>   X, Y <span class="op">=</span> torch.meshgrid(x, y, indexing<span class="op">=</span><span class="st">'ij'</span>)</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>   points <span class="op">=</span> torch.stack([X.flatten(), Y.flatten()], dim<span class="op">=</span><span class="dv">1</span>).to(device)</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>   <span class="co"># with torch.no_grad():</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>   <span class="co">#     t =  0.5  # Show flow field at t=0.5</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>   <span class="co">#     ones = torch.ones(points.size(0), 1)</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>   ones <span class="op">=</span> torch.ones(points.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device)</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>   t <span class="op">=</span> ones <span class="op">*</span> (<span class="fl">0.5</span>)</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>   velocities <span class="op">=</span> model(points, t).cpu()</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>   <span class="co">#print("points.shape, ones.shape = ",points.shape, ones.shape)</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>   <span class="co">#velocities = model(points, t*ones)</span></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>   points <span class="op">=</span> points.cpu()</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>   plt.quiver(points[:, <span class="dv">0</span>], points[:, <span class="dv">1</span>],</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>             velocities[:, <span class="dv">0</span>], velocities[:, <span class="dv">1</span>],</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>             alpha<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span>line_color, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>   plt.title(<span class="st">'Learned Flow Field</span><span class="ch">\n</span><span class="st">at t=0.5'</span>)</span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>   plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>   <span class="co"># 3. Plot actual paths taken using learned flow</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>   plt.subplot(<span class="dv">133</span>)</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>   source <span class="op">=</span> create_gaussian_data(n_trajs)</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Use RK4 to follow the learned flow</span></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>   paths <span class="op">=</span> []</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>   n_steps <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>   dt <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> n_steps</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>   <span class="cf">with</span> torch.no_grad():</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>       ones <span class="op">=</span> torch.ones(current_points.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device)</span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>       <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>           paths.append(current_points.clone())</span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>           <span class="co"># RK4 step</span></span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>           t <span class="op">=</span> ones <span class="op">*</span> (i <span class="op">*</span> dt)</span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>           k1 <span class="op">=</span> model(current_points, t)</span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a>           k2 <span class="op">=</span> model(current_points <span class="op">+</span> k1 <span class="op">*</span> dt<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a>           k3 <span class="op">=</span> model(current_points <span class="op">+</span> k2 <span class="op">*</span> dt<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a>           k4 <span class="op">=</span> model(current_points <span class="op">+</span> k3 <span class="op">*</span> dt, t <span class="op">+</span> dt)</span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a>           current_points <span class="op">=</span> current_points <span class="op">+</span> (k1 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k2 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k3 <span class="op">+</span> k4) <span class="op">*</span> dt<span class="op">/</span><span class="dv">6</span></span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-71"><a href="#cb18-71" aria-hidden="true" tabindex="-1"></a>   paths <span class="op">=</span> torch.stack(paths).cpu()</span>
<span id="cb18-72"><a href="#cb18-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-73"><a href="#cb18-73" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Plot the actual paths</span></span>
<span id="cb18-74"><a href="#cb18-74" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_trajs):</span>
<span id="cb18-75"><a href="#cb18-75" aria-hidden="true" tabindex="-1"></a>       traj <span class="op">=</span> paths[:, i, :]</span>
<span id="cb18-76"><a href="#cb18-76" aria-hidden="true" tabindex="-1"></a>       plt.plot(traj[:, <span class="dv">0</span>], traj[:, <span class="dv">1</span>], color<span class="op">=</span>line_color, alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb18-77"><a href="#cb18-77" aria-hidden="true" tabindex="-1"></a>   plt.title(<span class="st">'Actual Paths</span><span class="ch">\n</span><span class="st">Following Learned Flow'</span>)</span>
<span id="cb18-78"><a href="#cb18-78" aria-hidden="true" tabindex="-1"></a>   plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb18-79"><a href="#cb18-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-80"><a href="#cb18-80" aria-hidden="true" tabindex="-1"></a>   plt.tight_layout()</span>
<span id="cb18-81"><a href="#cb18-81" aria-hidden="true" tabindex="-1"></a>   plt.savefig(<span class="st">'images/cross_uncross_plot.png'</span>)</span>
<span id="cb18-82"><a href="#cb18-82" aria-hidden="true" tabindex="-1"></a>   plt.show()</span>
<span id="cb18-83"><a href="#cb18-83" aria-hidden="true" tabindex="-1"></a>   plt.close()</span>
<span id="cb18-84"><a href="#cb18-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-85"><a href="#cb18-85" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the visualization</span></span>
<span id="cb18-86"><a href="#cb18-86" aria-hidden="true" tabindex="-1"></a>plot_training_trajectories_vs_learned_flow(fm_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>…So we see that even though the model was trained using lots of crossing paths, it learned a smooth flow from them!</p>
<p>Even though the trajectories on the right are smooth and non-crossing, their curviness means that we need to integrate slowly and carefully to avoid accruing significant error. Good news: the “Rectified Flow” paper of Liu et al [2] offers a powerful way to speed up the integration by “straightening” the curved trajectories, a method they call “Reflow.”</p>
</section>
</section>
<section id="reflow-to-go-straighter-faster" class="level1">
<h1>“Reflow” to Go Straighter &amp; Faster</h1>
<p>The Reflow idea is that, instead of randomly pairing source and target points when choose straight trajectories, we use “simulated target points” by integrating the source points forward using the learned flow model. Then we use those endpoints as the targets and assume linear motion as before.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="data:image/png;base64,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ZjFlZTBjNGI0NWRhIgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmE5YTliY2Q4LWFjNDAtNDljMy1iYmU4LWM1YmJhYzdiYThjOSIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjUwNjRmMzBmLWRkOTUtNGM5OS1iNjg1LWUwYjIxYTMwNjQ2NSIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIEdJTVA6QVBJPSIyLjAiCiAgIEdJTVA6UGxhdGZvcm09IldpbmRvd3MiCiAgIEdJTVA6VGltZVN0YW1wPSIxNzMxMDM0ODE5MTE4OTUwIgogICBHSU1QOlZlcnNpb249IjIuMTAuMzgiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIgogICB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0OjExOjA3VDIxOjAwOjE5LTA2OjAwIgogICB4bXA6TW9kaWZ5RGF0ZT0iMjAyNDoxMTowN1QyMTowMDoxOS0wNjowMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmVkY2VkN2EyLTU3MDItNGMxYy04MDQ1LTU3NGJiNmQ2ZmEyNiIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNC0xMS0wN1QyMTowMDoxOSIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAg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.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">reflow_diagram.png</figcaption>
</figure>
</div>
<p>This has the effect of straightening out the curved trajectory of the flow matching model, making the new “reflowed” trajectories much easier and faster to integrate!</p>
<p>Essentially, Reflow is a “teacher-student” paradigm in which the (pre-)trained flow-matching model is the teacher, and new Reflowed model is the student. One can also think of this as a kind of distillation, akin to “consistency models” <span class="citation" data-cites="consistency_models">[@consistency_models]</span>.</p>
<p>Before we can rely on those integrated endpoints, we should make a couple improvements to how we use the model we just trained.</p>
<section id="upgrading-our-gear-first" class="level2">
<h2 class="anchored" data-anchor-id="upgrading-our-gear-first">Upgrading Our Gear First</h2>
<p>Neither of these upgrades require to retraining the model. The just help to make efficient, accurate use of it so we can use it as an effective “teacher” to the “student” reflow model we’ll train below.</p>
<section id="more-points-where-needed-via-time-warping" class="level3">
<h3 class="anchored" data-anchor-id="more-points-where-needed-via-time-warping">More Points Where Needed (via Time Warping)</h3>
<p>You’ll notice that trajectories are sharply curved in the middle, but are straight near the start and end. Just as you’d slow down when driving around a sharp turn, we should take smaller integration steps in these curved regions for accuracy.</p>
<p>This idea of non-uniform temporal sampling appears throughout generative models. Esser et al.’s “FLUX” paper specifically designs their sampling distribution to concentrate points in the middle of the integration where accuracy is most crucial. The same principle applies here: during training, we need good coverage where the model needs to make careful predictions, and during inference, high-curvature regions require denser sampling.</p>
<p>One handy S-shaped time-warping function is this polynomial that lets us vary the concentration of points<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<p><span class="math display">\[ f(t) =  4(1-s)t^3 + 6(s-1) t^2 + (3-2s)t, \ \ \ \ \ \  t\in[0,1], \ \ \ s\in[0,3/2] \]</span></p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title . (embed Desmos animation)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Jupyter's markdown won't perform the iframe embed unless we "execute" the HTML code??</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>HTML(<span class="st">"""</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;center&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;a href="https://www.desmos.com/calculator/g6ffbljlng"&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;iframe src="https://www.desmos.com/calculator/hfjxlwycmz?embed" width="225" height="225" style="border: 1px solid #ccc" frameborder=0&gt;&lt;/iframe&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;br&gt;Interactive Desmos Graph Link&lt;/a&gt;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;br&gt;&lt;br&gt;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The parameter <span class="math inline">\(s\)</span> is the slope at t=1/2, and controls where points concentrate: values between 0 and 1 give us more points in the middle, which is exactly what we want for these curved trajectories. The value <span class="math inline">\(s=0.5\)</span> is a good choice, as we’ll see shortly.</p>
<p>This approach can improve accuracy and/or require fewer total integration steps. Let’s look at the results of different amounts of time-warping around a simple parabola:</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code for warp_time function</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> warp_time(t, dt<span class="op">=</span><span class="va">None</span>, s<span class="op">=</span><span class="fl">.5</span>):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parametric Time Warping: s = slope in the middle.</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">        s=1 is linear time, s &lt; 1 goes slower near the middle, s&gt;1 goes slower near the ends</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">        s = 1.5 gets very close to the "cosine schedule", i.e. (1-cos(pi*t))/2, i.e. sin^2(pi/2*x)"""</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> s<span class="op">&lt;</span><span class="dv">0</span> <span class="kw">or</span> s<span class="op">&gt;</span><span class="fl">1.5</span>: <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"s=</span><span class="sc">{</span>s<span class="sc">}</span><span class="ss"> is out of bounds."</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    tw <span class="op">=</span> <span class="dv">4</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>s)<span class="op">*</span>t<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">6</span><span class="op">*</span>(s<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span><span class="op">-</span><span class="dv">2</span><span class="op">*</span>s)<span class="op">*</span>t</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dt:                           <span class="co"># warped time-step requested; use derivative</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tw,  dt <span class="op">*</span> <span class="dv">12</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>s)<span class="op">*</span>t<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">12</span><span class="op">*</span>(s<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>t <span class="op">+</span> (<span class="dv">3</span><span class="op">-</span><span class="dv">2</span><span class="op">*</span>s)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tw</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code to viz parabola example</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>parab   <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">4</span><span class="op">*</span>(x<span class="op">-</span><span class="fl">0.5</span>)<span class="op">**</span><span class="dv">2</span>  <span class="co"># curve shape</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>d_parab <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">8</span><span class="op">*</span>(x<span class="op">-</span><span class="fl">0.5</span>)     <span class="co"># derivative</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>ds      <span class="op">=</span> <span class="kw">lambda</span> x: torch.sqrt(<span class="dv">1</span> <span class="op">+</span> d_parab(x)<span class="op">**</span><span class="dv">2</span>)  <span class="co"># differential arc length</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_total_arc_length(n<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the total arc length of the parabola y = 4(x - 0.5)**2 from x=0 to x=1"""</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    x_values <span class="op">=</span> torch.linspace(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    arc_length_values <span class="op">=</span> ds(x_values)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    total_arc_length <span class="op">=</span> torch.trapz(arc_length_values, x_values)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_arc_length</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fake_velocity_model(loc, t, speed<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""For demo purposes only: Follow a parabolic path and move at unit speed</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute the x and y components of the velocity along the parabola y = 4(x - 0.5)^2"""</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> loc[:, <span class="dv">0</span>], loc[:, <span class="dv">1</span>]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    slope <span class="op">=</span> d_parab(x)</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    direction <span class="op">=</span> torch.stack([torch.ones_like(slope), slope], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    magnitude <span class="op">=</span> torch.norm(direction, dim<span class="op">=</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    unit_velocity <span class="op">=</span> direction <span class="op">/</span> magnitude</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> unit_velocity<span class="op">*</span>speed</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integrate_motion_along_parabola(</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        model, initial_points, n_steps<span class="op">=</span><span class="dv">30</span>, step_fn<span class="op">=</span>fwd_euler_step, s<span class="op">=</span><span class="fl">0.5</span>,):</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""one-off integrator used only for this one visualization figure. don't use for anything else"""</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    current_points <span class="op">=</span> initial_points.clone()</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    trajectories <span class="op">=</span> [current_points.cpu().clone()]</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>    ts <span class="op">=</span> torch.linspace(<span class="dv">0</span>,<span class="fl">1.0</span>, n_steps)</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>    ts <span class="op">=</span> warp_time(ts, s<span class="op">=</span>s)                <span class="co"># here's the time worpage</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>    speed <span class="op">=</span> calculate_total_arc_length()   <span class="co"># Total travel time is 1.0 so speed "=" distance</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    scaled_model <span class="op">=</span> partial(model, speed<span class="op">=</span>speed)</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>            current_points <span class="op">=</span> step_fn( scaled_model , current_points.clone(), ts[i],  ts[i<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>ts[i])</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>            trajectories.append(current_points.cpu().clone())</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack(trajectories)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> viz_parabola_with_steps(step_fn<span class="op">=</span>fwd_euler_step, n_steps<span class="op">=</span><span class="dv">28</span>):</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""varies warp parameter s and integrates along a parabola"""</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>    t_curve <span class="op">=</span> torch.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">100</span>)</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    n_t_points <span class="op">=</span> n_steps <span class="co"># 28 if step_fn==fwd_euler_step else 6</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>    t_points <span class="op">=</span> torch.linspace(<span class="dv">0</span>,<span class="dv">1</span>,n_t_points)</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>    n_s <span class="op">=</span> <span class="dv">6</span>    <span class="co"># number of different s values to show</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_s, figsize<span class="op">=</span>(n_s<span class="op">*</span><span class="fl">2.8</span>, <span class="dv">3</span>))</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="ss">f"Integration scheme = </span><span class="sc">{</span>step_fn<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">"</span>, fontsize<span class="op">=</span><span class="dv">16</span>, y<span class="op">=</span><span class="fl">1.05</span>)</span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>    initial_points <span class="op">=</span> torch.tensor([[<span class="dv">0</span>,<span class="dv">1</span>]])                   <span class="co"># one point in the top left</span></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(torch.linspace(<span class="fl">.25</span>, <span class="fl">1.5</span>, n_s)):   <span class="co"># warp time by different amounts via s parameter</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>        ax[i].plot(t_curve, parab(t_curve))    <span class="co"># solid line showing path</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>        traj <span class="op">=</span> integrate_motion_along_parabola(fake_velocity_model, initial_points, n_steps<span class="op">=</span>n_t_points,</span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">=</span>s, step_fn<span class="op">=</span>step_fn).squeeze()</span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>        err_str <span class="op">=</span> <span class="ss">f"</span><span class="ch">\n</span><span class="ss">error=</span><span class="sc">{</span>F<span class="sc">.</span>mse_loss(parab(traj[:,<span class="dv">0</span>]),traj[:,<span class="dv">1</span>])<span class="sc">:.3g}</span><span class="ss">"</span></span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a>        ax[i].scatter(traj[:,<span class="dv">0</span>], traj[:,<span class="dv">1</span>], label<span class="op">=</span><span class="ss">f's = </span><span class="sc">{</span>s<span class="sc">:.2f}{</span>err_str<span class="sc">}</span><span class="ss">'</span>, color<span class="op">=</span>(wong_cmap<span class="op">*</span><span class="dv">2</span>)[i])</span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a>        legend <span class="op">=</span> ax[i].legend(loc<span class="op">=</span><span class="st">'upper center'</span>, frameon<span class="op">=</span><span class="va">False</span>, markerscale<span class="op">=</span><span class="dv">0</span>, handlelength<span class="op">=</span><span class="dv">0</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb21-62"><a href="#cb21-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> text <span class="kw">in</span> legend.get_texts():</span>
<span id="cb21-63"><a href="#cb21-63" aria-hidden="true" tabindex="-1"></a>            text.set_ha(<span class="st">'center'</span>)</span>
<span id="cb21-64"><a href="#cb21-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-65"><a href="#cb21-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(s<span class="op">-</span><span class="fl">1.0</span>) <span class="op">&lt;</span> <span class="fl">1e-6</span>: ax[i].set_title(<span class="st">'Even Spacing'</span>)</span>
<span id="cb21-66"><a href="#cb21-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-67"><a href="#cb21-67" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].set_title(<span class="st">'More Points in Middle'</span>)</span>
<span id="cb21-68"><a href="#cb21-68" aria-hidden="true" tabindex="-1"></a>    ax[<span class="op">-</span><span class="dv">1</span>].set_title(<span class="st">'More Points at Ends'</span>)</span>
<span id="cb21-69"><a href="#cb21-69" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb21-70"><a href="#cb21-70" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb21-71"><a href="#cb21-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-72"><a href="#cb21-72" aria-hidden="true" tabindex="-1"></a>viz_parabola_with_steps(fm_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>While the results for <span class="math inline">\(s=0.5\)</span> are better than the others, we see that <em>none</em> of these examples make it all the way around the parabola (to the point (1,1))! If we’re going to be using the flow matching model as a proxy for the true target data, we should have some confidence that it’s actually “getting to” the target data. We could add more points to the integration, but there’s another way: upgrade the integration (i.e.&nbsp;sampling) operation to a higher order of accuracy.</p>
</section>
<section id="better-integration-sampling" class="level3">
<h3 class="anchored" data-anchor-id="better-integration-sampling">Better Integration / Sampling</h3>
<p>While forward Euler is surprisingly popular in ML circles, those with simulation backgrounds eye it with suspicion: despite being being fast and easy to implement, it’s also highly inaccurate and can lead to instabilities. The poor accuracy may not be an issue when everything’s an approximation anyway, but we can do a lot better.</p>
<p>People who work with diffusion models know this, e.g.&nbsp;in <a href="https://github.com/crowsonkb/k-diffusion">Katherine Crowson’s k-diffusion package</a> offers a bevy of integration choices. For here we’ll just implement the popular 4th-order Runge-Kutta (RK4) scheme. It’s more “expensive” than forward Euler in that each step requires 4 function evaluations instead of forward Euler’s 1 step, and it requires some extra storage, but the advantages you gain in accuracy are seriously worth it (e.g., because you can take much longer steps in time).</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code for 4th-order Runge-Kutta integration"</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rk4_step(f, <span class="co"># function that takes (t,y) and returns dy/dt, i.e. velocity</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>             y, <span class="co"># current location</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>             t, <span class="co"># current t value</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>             dt, <span class="co"># requested time step size</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>             ):</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span>  f(y, t)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    k2 <span class="op">=</span>  f(y <span class="op">+</span> dt<span class="op">*</span>k1<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    k3 <span class="op">=</span>  f(y <span class="op">+</span> dt<span class="op">*</span>k2<span class="op">/</span><span class="dv">2</span>, t <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    k4 <span class="op">=</span>  f(y <span class="op">+</span> dt<span class="op">*</span>k3, t <span class="op">+</span> dt)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y <span class="op">+</span> (dt<span class="op">/</span><span class="dv">6</span>)<span class="op">*</span>(k1 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k2 <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>k3 <span class="op">+</span> k4)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>viz_parabola_with_steps(step_fn<span class="op">=</span>rk4_step, n_steps<span class="op">=</span><span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It’s cool how the RK4 results, despite showing less error that the Euler results, actually involve <em>less</em> computational cost in terms of number of function evaluations, though the RK4 scheme needs 4 times the storage compared for forward Euler. (The good news is that no PyTorch gradients need to be stored; the integrator is only ever used when the model is in “eval” mode.)</p>
</section>
</section>
<section id="reflow-to-go-straight-and-fast" class="level2">
<h2 class="anchored" data-anchor-id="reflow-to-go-straight-and-fast">“ReFlow” to Go Straight and Fast</h2>
<p>When we train the student model, aka the rectified model, note that the “target data” will no longer be supplied by the true target data anymore. Rather we will be using the trajectory endpoints integrated/generated using the teacher model, i.e.&nbsp;the pretrained flow model.</p>
<p>So…. how close of an approximation are those learned flow endpoints to the real thing? We’re going to be approximating an approximation, but how good is the original approximation?</p>
<p>Let’s take a look…</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Quick check of how our flow endpoints are looking</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>pretrained_model <span class="op">=</span> fm_model</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>pretrained_model.<span class="bu">eval</span>()</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>reflow_targets <span class="op">=</span> integrate_path(pretrained_model, val_points.to(device), n_steps<span class="op">=</span><span class="dv">8</span>, step_fn<span class="op">=</span>rk4_step, warp_fn<span class="op">=</span>warp_time).cpu()</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">3</span>))</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, [data, color, label] <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>([val_points,   reflow_targets, target_samples],</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>                                             [source_color, pred_color,     target_color],</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>                                             [<span class="st">'Source Data'</span>, <span class="st">'Learned Flow Endpoints'</span>, <span class="st">'True Target Data'</span>])):</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    ax[i].scatter(data[:,<span class="dv">0</span>], data[:,<span class="dv">1</span>], color<span class="op">=</span>color, label<span class="op">=</span>label, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    ax[i].set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(label)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>….ok, so we see the learned outputs are a bit different from the true data, but they’re not bad. Let’s now train the “reflow” model.</p>
<section id="train-the-reflowed-model" class="level3">
<h3 class="anchored" data-anchor-id="train-the-reflowed-model">Train the Reflowed Model</h3>
<p>There’s one small but crucial change from the previous training code to this one, namely what we use as target data:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">##  target_samples = create_target_data(batch_size)           # Previous "random pairing"</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>target_samples <span class="op">=</span> integrator(pretrained_model, source_samples) <span class="co"># Reflow!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code for new Training loop w/ ReFlowed targets</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_reflow_model(model, pretrained_model<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>                          n_epochs<span class="op">=</span><span class="dv">40</span>, lr<span class="op">=</span><span class="fl">0.001</span>, batch_size<span class="op">=</span><span class="dv">2048</span>,</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>                          status_every<span class="op">=</span><span class="dv">1</span>, viz_every<span class="op">=</span><span class="dv">1</span>, <span class="co"># in epochs</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>                          new_points_every<span class="op">=</span><span class="dv">1</span>, <span class="co"># in steps</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>                          warp_fn<span class="op">=</span>warp_time,</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>                          step_fn<span class="op">=</span>rk4_step, <span class="co"># rk4 so we get high-quality outputs while reflowing</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>                          ):</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""This is almost IDENTICAL to the previous training routine.</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co">        The difference is the change in "target_samples" via what the RF authors call "ReFlow":</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Instead of (randomly) paring source points with points in the "true target distribution",</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="co">        we use the pretrained/teacher model to integrate the source points to their (predicted) flow endpoints</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co">        and use THOSE as the "target" values.</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    optimizer <span class="op">=</span> optim.Adam(model.parameters(), lr<span class="op">=</span>lr)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    loss_fn <span class="op">=</span> nn.MSELoss()</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    step, n_steps <span class="op">=</span> <span class="dv">0</span>, <span class="dv">100</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        model.train()</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        pbar <span class="op">=</span> tqdm(<span class="bu">range</span>(n_steps), leave<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> pbar:</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>            step <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> step <span class="op">%</span> new_points_every <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># you could in theory not draw new points with each step, though we will.</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>                source_samples <span class="op">=</span> create_source_data(batch_size).to(device)</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pretrained_model:   <span class="co"># HERE is the ReFlow operation...</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>                    target_samples <span class="op">=</span> integrate_path(pretrained_model, source_samples, step_fn<span class="op">=</span>rk4_step, warp_fn<span class="op">=</span>warp_time, n_steps<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>                    target_samples <span class="op">=</span> create_target_data(batch_size) <span class="co"># this function also supports fm models from scratch</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> torch.rand(source_samples.size(<span class="dv">0</span>), <span class="dv">1</span>).to(device) <span class="co"># random times for training</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> warp_fn: t <span class="op">=</span> warp_fn(t)  <span class="co"># time warp here (different from use in integrator!) helps focus "coverage" i.e. sampling the space</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>            interpolated_samples <span class="op">=</span> source_samples <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> t) <span class="op">+</span> target_samples <span class="op">*</span> t</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> model(interpolated_samples, t)</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>            line_directions <span class="op">=</span> target_samples <span class="op">-</span> source_samples</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> loss_fn(v, line_directions)</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>            loss.backward()</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>            pbar.set_description(<span class="ss">f'Epoch [</span><span class="sc">{</span>epoch <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>n_epochs<span class="sc">}</span><span class="ss">], Loss: </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">:.4g}</span><span class="ss">'</span>)</span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (epoch <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> viz_every <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>            model.<span class="bu">eval</span>()</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>            clear_output(wait<span class="op">=</span><span class="va">True</span>)  <span class="co"># Clear previous plots</span></span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>            viz(val_points, target_samples[:val_points.shape[<span class="dv">0</span>]], model)  <span class="co"># don't need rk4 for rect model viz b/c paths r straight</span></span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>            plt.show()</span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>            plt.close()  <span class="co"># Close the figure to free memory</span></span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>            model.train()</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> copy</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>reflowed_model <span class="op">=</span> copy.deepcopy(pretrained_model) <span class="co"># no need to train student from scratch, start from teacher's weights</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>reflowed_model.train()</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>reflowed_model <span class="op">=</span> train_reflow_model(reflowed_model, pretrained_model<span class="op">=</span>pretrained_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Oooo, look how straight the trajectories are now! Let’s compare animations of the original flow matching model with the “Reflowed” model:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>rect_eval <span class="op">=</span> reflowed_model.<span class="bu">eval</span>()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>anim_file <span class="op">=</span> <span class="va">None</span> <span class="co"># "images/particles_fm_vs_rf.mp4"</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>create_flow_animation(val_points.clone(), models<span class="op">=</span>[pretrained_model, reflowed_model],</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        n_frames<span class="op">=</span><span class="dv">50</span>, titles<span class="op">=</span>[<span class="st">'Flow Matching'</span>,<span class="st">'Reflowed Flow'</span>], save_file<span class="op">=</span>anim_file)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notice how the flow matching trajectories on the left have the data moving inward a ways and then back out, whereas the reflowed trajectories move directly from start to finish with no backtracking.</p>
<p>The next movie shows an animation of “streamlines” with arrows for the local vector field. Note how the shapes on the right change very little over time compared to those on the left. We’ll say a bit more about that below.</p>
<div class="cell" data-cellview="form">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># @title Code to produce streamline animation (take a little while to run)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.no_grad</span>()</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_streamline_animation(start_dist, model, model2<span class="op">=</span><span class="va">None</span>, n_frames<span class="op">=</span><span class="dv">50</span>, show_points<span class="op">=</span><span class="va">False</span>, titles<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                                step_fn<span class="op">=</span>fwd_euler_step,  <span class="co"># euler's ok for reflowed model bc/paths are straight</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                                save_file<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>                               ):</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create an animation showing distribution flow with streamplot background"""</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> <span class="bu">next</span>(model.parameters()).device</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    figsize <span class="op">=</span> [<span class="dv">5</span>,<span class="dv">5</span>]</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> titles <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        titles <span class="op">=</span> [<span class="st">'Flow Matching'</span>]</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2: titles <span class="op">+=</span> [<span class="st">'Rectified Flow'</span>]</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model2:</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        figsize[<span class="dv">0</span>] <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    n_plots <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> (model2 <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, n_plots, figsize<span class="op">=</span>figsize)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_plots<span class="op">==</span><span class="dv">1</span>: ax <span class="op">=</span> [ax]</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    end_dist, trajectories <span class="op">=</span> integrate_path(model, start_dist.clone().to(device), n_steps<span class="op">=</span>n_frames, step_fn<span class="op">=</span>step_fn, warp_fn<span class="op">=</span>warp_time, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    scatter <span class="op">=</span> ax[<span class="dv">0</span>].scatter([], [], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>wong_pink, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model2:</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>        _, trajectories2 <span class="op">=</span> integrate_path(model2, start_dist.clone().to(device), n_steps<span class="op">=</span>n_frames, step_fn<span class="op">=</span>step_fn, warp_fn<span class="op">=</span>warp_time, save_trajectories<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>        scatter2 <span class="op">=</span> ax[<span class="dv">1</span>].scatter([], [], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>wong_pink, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    max_range <span class="op">=</span> <span class="bu">max</span>( <span class="bu">abs</span>(start_dist).<span class="bu">max</span>().item(), <span class="bu">abs</span>(end_dist).<span class="bu">max</span>().item() )</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ax)):</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>        ax[i].set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>        ax[i].set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>        ax[i].set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> titles: ax[i].set_title(titles[i])</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create grid for streamplot</span></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    grid_dim <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, grid_dim)</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, grid_dim)</span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>    X, Y <span class="op">=</span> np.meshgrid(x, y)</span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert grid to torch tensor for model input</span></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>    grid_points <span class="op">=</span> torch.tensor(np.stack([X.flatten(), Y.flatten()], axis<span class="op">=</span><span class="dv">1</span>), dtype<span class="op">=</span>torch.float32).to(device)</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> wong_pink <span class="cf">if</span> show_points <span class="cf">else</span> (<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> n_frames</span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> init():</span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ax)):</span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>            ax[i].clear()</span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>            ax[i].set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>            ax[i].set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>        scatter.set_offsets(np.c_[[], []])</span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2:</span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>                scatter.set_offsets(np.c_[[], []])</span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (scatter,scatter2)</span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (scatter,)</span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> animate(frame):</span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ax)):</span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>            ax[i].clear()</span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a>            ax[i].set_xlim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a>            ax[i].set_ylim((<span class="op">-</span>max_range, max_range))</span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> titles: ax[i].set_title(titles[i])</span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a>            ax[i].set_xticks([])</span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a>            ax[i].set_yticks([])</span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> spine <span class="kw">in</span> [<span class="st">'top'</span>,<span class="st">'right'</span>,<span class="st">'bottom'</span>,<span class="st">'left'</span>]:</span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a>                ax[i].spines[spine].set_visible(<span class="va">False</span>)</span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update scatter plot</span></span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> trajectories[frame]</span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a>        scatter <span class="op">=</span> ax[<span class="dv">0</span>].scatter(current[:, <span class="dv">0</span>], current[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>color, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2:</span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a>            current2 <span class="op">=</span> trajectories2[frame]</span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a>            scatter2 <span class="op">=</span> ax[i].scatter(current2[:, <span class="dv">0</span>], current2[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>color, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-75"><a href="#cb28-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-76"><a href="#cb28-76" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate vector field for current time</span></span>
<span id="cb28-77"><a href="#cb28-77" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> torch.ones(grid_points.size(<span class="dv">0</span>), <span class="dv">1</span>) <span class="op">*</span> (frame <span class="op">*</span> dt)</span>
<span id="cb28-78"><a href="#cb28-78" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> warp_time(t).to(device)</span>
<span id="cb28-79"><a href="#cb28-79" aria-hidden="true" tabindex="-1"></a>        velocities <span class="op">=</span> model(grid_points, t).cpu()</span>
<span id="cb28-80"><a href="#cb28-80" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> velocities[:, <span class="dv">0</span>].reshape(X.shape)</span>
<span id="cb28-81"><a href="#cb28-81" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> velocities[:, <span class="dv">1</span>].reshape(X.shape)</span>
<span id="cb28-82"><a href="#cb28-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-83"><a href="#cb28-83" aria-hidden="true" tabindex="-1"></a>        x_points <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, <span class="dv">15</span>)</span>
<span id="cb28-84"><a href="#cb28-84" aria-hidden="true" tabindex="-1"></a>        y_points <span class="op">=</span> np.linspace(<span class="op">-</span>max_range, max_range, <span class="dv">15</span>)</span>
<span id="cb28-85"><a href="#cb28-85" aria-hidden="true" tabindex="-1"></a>        X_arrows, Y_arrows <span class="op">=</span> np.meshgrid(x_points, y_points)</span>
<span id="cb28-86"><a href="#cb28-86" aria-hidden="true" tabindex="-1"></a>        start_points <span class="op">=</span> np.column_stack((X_arrows.ravel(), Y_arrows.ravel()))</span>
<span id="cb28-87"><a href="#cb28-87" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].streamplot(X, Y, U.numpy(), V.numpy(),</span>
<span id="cb28-88"><a href="#cb28-88" aria-hidden="true" tabindex="-1"></a>             density<span class="op">=</span><span class="dv">5</span>,  <span class="co"># Controls line spacing</span></span>
<span id="cb28-89"><a href="#cb28-89" aria-hidden="true" tabindex="-1"></a>             color<span class="op">=</span>line_color, <span class="co"># (0, 0, 1, 0.7),</span></span>
<span id="cb28-90"><a href="#cb28-90" aria-hidden="true" tabindex="-1"></a>             linewidth<span class="op">=</span><span class="fl">0.8</span>, maxlength<span class="op">=</span><span class="fl">0.12</span>,</span>
<span id="cb28-91"><a href="#cb28-91" aria-hidden="true" tabindex="-1"></a>             start_points<span class="op">=</span>start_points,  <span class="co"># This should give more arrows along paths</span></span>
<span id="cb28-92"><a href="#cb28-92" aria-hidden="true" tabindex="-1"></a>             arrowsize<span class="op">=</span><span class="fl">1.2</span>,</span>
<span id="cb28-93"><a href="#cb28-93" aria-hidden="true" tabindex="-1"></a>             arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>)</span>
<span id="cb28-94"><a href="#cb28-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-95"><a href="#cb28-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2:</span>
<span id="cb28-96"><a href="#cb28-96" aria-hidden="true" tabindex="-1"></a>            velocities2 <span class="op">=</span> model2(grid_points, t).cpu()</span>
<span id="cb28-97"><a href="#cb28-97" aria-hidden="true" tabindex="-1"></a>            U2 <span class="op">=</span> velocities2[:, <span class="dv">0</span>].reshape(X.shape)</span>
<span id="cb28-98"><a href="#cb28-98" aria-hidden="true" tabindex="-1"></a>            V2 <span class="op">=</span> velocities2[:, <span class="dv">1</span>].reshape(X.shape)</span>
<span id="cb28-99"><a href="#cb28-99" aria-hidden="true" tabindex="-1"></a>            start_points2 <span class="op">=</span> np.column_stack((X_arrows.ravel(), Y_arrows.ravel()))</span>
<span id="cb28-100"><a href="#cb28-100" aria-hidden="true" tabindex="-1"></a>            ax[<span class="dv">1</span>].streamplot(X, Y, U2.numpy(), V2.numpy(),</span>
<span id="cb28-101"><a href="#cb28-101" aria-hidden="true" tabindex="-1"></a>                 density<span class="op">=</span><span class="dv">5</span>,  <span class="co"># Controls line spacing</span></span>
<span id="cb28-102"><a href="#cb28-102" aria-hidden="true" tabindex="-1"></a>                 color<span class="op">=</span>line_color, <span class="co"># (0, 0, 1, 0.7),</span></span>
<span id="cb28-103"><a href="#cb28-103" aria-hidden="true" tabindex="-1"></a>                 linewidth<span class="op">=</span><span class="fl">0.8</span>, maxlength<span class="op">=</span><span class="fl">0.12</span>,</span>
<span id="cb28-104"><a href="#cb28-104" aria-hidden="true" tabindex="-1"></a>                 start_points<span class="op">=</span>start_points2,  <span class="co"># This should give more arrows along paths</span></span>
<span id="cb28-105"><a href="#cb28-105" aria-hidden="true" tabindex="-1"></a>                 arrowsize<span class="op">=</span><span class="fl">1.2</span>,</span>
<span id="cb28-106"><a href="#cb28-106" aria-hidden="true" tabindex="-1"></a>                 arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>)</span>
<span id="cb28-107"><a href="#cb28-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-108"><a href="#cb28-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-109"><a href="#cb28-109" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update particle positions</span></span>
<span id="cb28-110"><a href="#cb28-110" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> torch.ones(current.size(<span class="dv">0</span>), <span class="dv">1</span>) <span class="op">*</span> (frame <span class="op">*</span> dt)</span>
<span id="cb28-111"><a href="#cb28-111" aria-hidden="true" tabindex="-1"></a>        t, dtw <span class="op">=</span> warp_time(t, dt<span class="op">=</span>dt)</span>
<span id="cb28-112"><a href="#cb28-112" aria-hidden="true" tabindex="-1"></a>        velocity <span class="op">=</span> model(current.to(device), t.to(device)).cpu()</span>
<span id="cb28-113"><a href="#cb28-113" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> current <span class="op">+</span> velocity <span class="op">*</span> dtw</span>
<span id="cb28-114"><a href="#cb28-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model2:</span>
<span id="cb28-115"><a href="#cb28-115" aria-hidden="true" tabindex="-1"></a>            velocity2 <span class="op">=</span> model2(current2.to(device), t.to(device)).cpu()</span>
<span id="cb28-116"><a href="#cb28-116" aria-hidden="true" tabindex="-1"></a>            current2 <span class="op">=</span> current2 <span class="op">+</span> velocity2 <span class="op">*</span> dtw</span>
<span id="cb28-117"><a href="#cb28-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (scatter, scatter2,)</span>
<span id="cb28-118"><a href="#cb28-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (scatter,)</span>
<span id="cb28-119"><a href="#cb28-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-120"><a href="#cb28-120" aria-hidden="true" tabindex="-1"></a>    anim <span class="op">=</span> animation.FuncAnimation(fig, animate, init_func<span class="op">=</span>init,</span>
<span id="cb28-121"><a href="#cb28-121" aria-hidden="true" tabindex="-1"></a>                                 frames<span class="op">=</span>n_frames, interval<span class="op">=</span><span class="dv">20</span>, blit<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb28-122"><a href="#cb28-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-123"><a href="#cb28-123" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> save_file:</span>
<span id="cb28-124"><a href="#cb28-124" aria-hidden="true" tabindex="-1"></a>        anim.save(save_file, writer<span class="op">=</span><span class="st">'ffmpeg'</span>, fps<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb28-125"><a href="#cb28-125" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(<span class="ss">f"""&lt;center&gt;&lt;video height="350" controls loop&gt;&lt;source src="</span><span class="sc">{</span>save_file<span class="sc">}</span><span class="ss">" type="video/mp4"&gt;</span></span>
<span id="cb28-126"><a href="#cb28-126" aria-hidden="true" tabindex="-1"></a><span class="ss">                      Your browser does not support the video tag.&lt;/video&gt;&lt;/center&gt;"""</span>)</span>
<span id="cb28-127"><a href="#cb28-127" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb28-128"><a href="#cb28-128" aria-hidden="true" tabindex="-1"></a>        rc(<span class="st">'animation'</span>, html<span class="op">=</span><span class="st">'jshtml'</span>)</span>
<span id="cb28-129"><a href="#cb28-129" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> HTML(anim.to_jshtml())</span>
<span id="cb28-130"><a href="#cb28-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-131"><a href="#cb28-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-132"><a href="#cb28-132" aria-hidden="true" tabindex="-1"></a>save_file <span class="op">=</span> <span class="va">None</span> <span class="co"># 'images/fm_vs_rf_streamvecs.mp4'</span></span>
<span id="cb28-133"><a href="#cb28-133" aria-hidden="true" tabindex="-1"></a>create_streamline_animation(val_points, fm_model, model2<span class="op">=</span>reflowed_model, n_frames<span class="op">=</span><span class="dv">50</span>, save_file<span class="op">=</span>save_file)<span class="co">#, show_points=True)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="connecting-with-other-models" class="level1">
<h1>Connecting with Other Models</h1>
<section id="from-dots-to-images-audio-etc.." class="level3">
<h3 class="anchored" data-anchor-id="from-dots-to-images-audio-etc..">From Dots to Images, Audio, etc..</h3>
<p>How to move on from 2D dots to things like images, text, audio,…etc? We need only consider that the dimensionality of the velocity model is the same as that of the data itself. Put differently, one can regard the velocity model as supply a tiny “change” to the data, whatever form that data is in. And the “straight line” trajectory used during training? That’s just linear interpolation between the (initially randomly-paired) source data and the target data. So for images, we will get a “velocity image”, which will tell us how to change the R,G,B value of every pixel in an image. This is where U-Nets and Attention come in to play, to compute the “image-to-image” task of supplying a “velocity image” given an input image distribution (which may just be noise). For audio, regardless of the representation, the velocity model will tell us how to slightly change the component values in that representation. We then just integrate all the little changes as we did with the dots.</p>
<ul>
<li>I recommend checking out an MNIST image example such as Tadao Yamaoka’s [8]</li>
</ul>
</section>
<section id="diffusion-models" class="level3">
<h3 class="anchored" data-anchor-id="diffusion-models">Diffusion Models</h3>
<p>Diffusion-models, aka “score-based models” are similar to flow models in that the former also learn a vector field (the “score function”) that serves to differentially transform the points in the sample. The difference is that flow models are deterministic, whereas diffusion models are constantly injecting fresh noise, as if they are simulating actual brownian motion rather than the macroscopic flow. To turn our flow model into a diffusion model, we could add “jitter,” i.e.&nbsp;inject noise at every step. The variance of that jitter as a function of time would correspond directly to the “noise schedule” of diffusion models.</p>
</section>
<section id="optimal-transport" class="level3">
<h3 class="anchored" data-anchor-id="optimal-transport">Optimal Transport</h3>
<p>Interesting observation: See how the Reflowed streamlines in the last movie are approximately stationary (i.e., time-independent)? This connects nicely with Optimal Transport theory, where the Benamou-Brenier formulation [9] (which has a diffusion-esque equation as on objective) shows that optimal mass transport paths follow constant-velocity geodesics in the Wasserstein metric space. This time-independence property emerges naturally when minimizing transport costs in simple metric spaces, as particles following straight-line paths at constant speeds achieve optimal transport between distributions.</p>
</section>
<section id="normalizing-flows" class="level3">
<h3 class="anchored" data-anchor-id="normalizing-flows">Normalizing Flows</h3>
<p>Normalizing flows have the property that they preserve overall probability throughout the flow process. It turns out that, while this would seem to be a nice constraint to satisfy, it is unnecessary for “getting the job done” and can limit the expressiveness of the model. Note: Since I’m pushing a “physics perspective,” a similar property arises in the phase space flows of Hamiltonian mechanics, which preserve area elements ala Liousville’s Theorem [10]. The connection between normalizing flows and Hamiltonian systems was applied to generative modeling in the “Neural Hamiltonian Flows” paper of ICLR 2020 [11], and continues in a recent NeurIPS 2024 poster-paper [12].<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Despite these fascinating connections, the exciting thing about flow-matching and rectified flows is that they seem to be effective even in the absence of the explicit conservation properties of normalizing flows and their relatives, and can thus be implemented quickly and simply.</p>
</section>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>We’ve seen that flow matching and rectified flows models can be conceptualized and even developed using some simple ideas from basic physics. This simplicy, coupled with their power and flexibility have fueled their popularity and even rise to state-of-the-art levels.</p>
<p>Hopefully, after having read this, you will be able to better follow the rapid progress in flow-based generative AI in terms of both scholarly and industry output, as well as to have the confidence to expand on these ideas for your own investigations!</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<p>[1] P. Esser et al., “Scaling rectified flow transformers for high-resolution image synthesis,” in 41st International Conference on Machine Learning, ICML, Vienna, Austria, 2024. Available: https://openreview.net/forum?id=FPnUhsQJ5B</p>
<p>[2] X. Liu, C. Gong, and Q. Liu, “Flow straight and fast: Learning to generate and transfer data with rectified flow,” in 11th International Conference on Learning Representations (ICLR), 2023. Available: https://openreview.net/forum?id=XVjTT1nw5z</p>
<p>[3] S. Lee, Z. Lin, and G. Fanti, “Improving the training of rectified flows.” 2024. Available: https://arxiv.org/abs/2405.20320</p>
<p>[4] J.-B. Huang, “How I understand flow matching.” YouTube, 2024. Available: https://www.youtube.com/watch?v=DDq_pIfHqLs</p>
<p>[5] T. Beier and S. Neely, “Feature-based image metamorphosis,” ACM SIGGRAPH Comput. Graph., vol.&nbsp;26, no. 2, pp.&nbsp;35–42, Jul.&nbsp;1992, doi: 10.1145/142920.134003.</p>
<p>[6] T. M. Abraham, ““Flow matching and rectified flows are the same.” X.com, 2024. Available: https://x.com/iScienceLuvr/status/1766700945243881889</p>
<p>[7] Y. Song, P. Dhariwal, M. Chen, and I. Sutskever, “Consistency models.” 2023. Available: https://arxiv.org/abs/2303.01469</p>
<p>[8] T. Yamaoka, “Image generation with rectified flow part 2 (learning MNIST using scratch implementation).” 2024. Available: https://tadaoyamaoka.hatenablog.com/entry/2024/09/29/163801</p>
<p>[9] J.-D. Benamou and Y. Brenier, “A computational fluid mechanics solution to the Monge-Kantorovich mass transfer problem,” Numerische Mathematik, vol.&nbsp;84, pp.&nbsp;375–393, 2000, Available: https://api.semanticscholar.org/CorpusID:1100384</p>
<p>[10] Wikipedia, “Liouville’s theorem (Hamiltonian) — Wikipedia, the free encyclopedia.” http://en.wikipedia.org/w/index.php?title=Liouville’s%20theorem%20(Hamiltonian)&amp;oldid=1233185478, 2024.</p>
<p>[11] P. Toth, D. J. Rezende, A. Jaegle, S. Racanière, A. Botev, and I. Higgins, “Hamiltonian generative networks,” in International Conference on Learning Representations (ICLR), 2020. Available: https://openreview.net/forum?id=HJenn6VFvB</p>
<p>[12] P. Holderrieth, Y. Xu, and T. Jaakkola, “Hamiltonian score matching and generative flows.” 2024. Available: https://arxiv.org/abs/2410.20470</p>
<hr>
<ol start="3" type="a">
<li>2024 Scott H. Hawley</li>
</ol>
<section id="acknowledgement" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="acknowledgement">Acknowledgement</h4>
<p>This work was graciously supported by Belmont University, Hyperstate Music AI, Razer Inc., and NVIDIA’s Inception program. Much of this tutorial was hashed out through “conversations” with Claude 3.5 Sonnet.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>A related example from science fiction: in the fictitous “psychohistory” theory in Isaac Asimov’s <em>Foundation</em> series, the individual choices and “trajectories” of individual people can’t be predicted, but the aggregated motion of an entire society follows predictable paths.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Note: my <span class="math inline">\(f(t)\)</span> is a close approximation to the “mode function” Eq. 20 in <a href="https://arxiv.org/abs/2403.03206">Esser et al</a>, with their <span class="math inline">\(s\)</span> being about (1.75 - <span class="math inline">\(s_{\rm mine}\)</span>), and with <span class="math inline">\(t\rightarrow 1-t\)</span>. My blue line is right underneath their purple line in the Desmos graph below – I didn’t plan that, just similar minds at work! Both our curves can do the Karras et al cosine schedule, shown in green in the the Desmos figure.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Check out <a href="https://yilun-xu.com/">Yilun Xu’s</a> work for more on physics-inspired generative models.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp("https:\/\/drscotthawley\.github\.io\/blog");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->



</body></html>